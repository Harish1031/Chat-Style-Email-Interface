"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mutative";
exports.ids = ["vendor-chunks/mutative"];
exports.modules = {

/***/ "(ssr)/./node_modules/mutative/dist/mutative.esm.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/mutative/dist/mutative.esm.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   castDraft: () => (/* binding */ castDraft),\n/* harmony export */   castImmutable: () => (/* binding */ castImmutable),\n/* harmony export */   castMutable: () => (/* binding */ castMutable),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   isDraft: () => (/* binding */ isDraft),\n/* harmony export */   isDraftable: () => (/* binding */ isDraftable),\n/* harmony export */   makeCreator: () => (/* binding */ makeCreator),\n/* harmony export */   markSimpleObject: () => (/* binding */ markSimpleObject),\n/* harmony export */   original: () => (/* binding */ original),\n/* harmony export */   rawReturn: () => (/* binding */ rawReturn),\n/* harmony export */   unsafe: () => (/* binding */ unsafe)\n/* harmony export */ });\nconst Operation = {\n    Remove: 'remove',\n    Replace: 'replace',\n    Add: 'add',\n};\n\n// Don't use `Symbol()` just for 3rd party access the draft\nconst PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');\nconst RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');\nconst iteratorSymbol = Symbol.iterator;\nconst dataTypes = {\n    mutable: 'mutable',\n    immutable: 'immutable',\n};\n\nconst internal = {};\n\nfunction has(target, key) {\n    return target instanceof Map\n        ? target.has(key)\n        : Object.prototype.hasOwnProperty.call(target, key);\n}\nfunction getDescriptor(target, key) {\n    if (key in target) {\n        let prototype = Reflect.getPrototypeOf(target);\n        while (prototype) {\n            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);\n            if (descriptor)\n                return descriptor;\n            prototype = Reflect.getPrototypeOf(prototype);\n        }\n    }\n    return;\n}\nfunction isBaseSetInstance(obj) {\n    return Object.getPrototypeOf(obj) === Set.prototype;\n}\nfunction isBaseMapInstance(obj) {\n    return Object.getPrototypeOf(obj) === Map.prototype;\n}\n\nfunction latest(proxyDraft) {\n    var _a;\n    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;\n}\n/**\n * Check if the value is a draft\n */\nfunction isDraft(target) {\n    return !!getProxyDraft(target);\n}\nfunction getProxyDraft(value) {\n    if (typeof value !== 'object')\n        return null;\n    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];\n}\nfunction getValue(value) {\n    var _a;\n    const proxyDraft = getProxyDraft(value);\n    return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;\n}\n/**\n * Check if a value is draftable\n */\nfunction isDraftable(value, options) {\n    if (!value || typeof value !== 'object')\n        return false;\n    let markResult;\n    return (Object.getPrototypeOf(value) === Object.prototype ||\n        Array.isArray(value) ||\n        value instanceof Map ||\n        value instanceof Set ||\n        (!!(options === null || options === void 0 ? void 0 : options.mark) &&\n            ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable ||\n                typeof markResult === 'function')));\n}\nfunction getPath(target, path = []) {\n    if (Object.hasOwnProperty.call(target, 'key')) {\n        // check if the parent is a draft and the original value is not equal to the current value\n        const parentCopy = target.parent.copy;\n        const proxyDraft = getProxyDraft(get(parentCopy, target.key));\n        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {\n            return null;\n        }\n        const isSet = target.parent.type === 3 /* DraftType.Set */;\n        const key = isSet\n            ? Array.from(target.parent.setMap.keys()).indexOf(target.key)\n            : target.key;\n        // check if the key is still in the next state parent\n        if (!((isSet && parentCopy.size > key) || has(parentCopy, key)))\n            return null;\n        path.push(key);\n    }\n    if (target.parent) {\n        return getPath(target.parent, path);\n    }\n    // `target` is root draft.\n    path.reverse();\n    try {\n        // check if the path is valid\n        resolvePath(target.copy, path);\n    }\n    catch (e) {\n        return null;\n    }\n    return path;\n}\nfunction getType(target) {\n    if (Array.isArray(target))\n        return 1 /* DraftType.Array */;\n    if (target instanceof Map)\n        return 2 /* DraftType.Map */;\n    if (target instanceof Set)\n        return 3 /* DraftType.Set */;\n    return 0 /* DraftType.Object */;\n}\nfunction get(target, key) {\n    return getType(target) === 2 /* DraftType.Map */ ? target.get(key) : target[key];\n}\nfunction set(target, key, value) {\n    const type = getType(target);\n    if (type === 2 /* DraftType.Map */) {\n        target.set(key, value);\n    }\n    else {\n        target[key] = value;\n    }\n}\nfunction peek(target, key) {\n    const state = getProxyDraft(target);\n    const source = state ? latest(state) : target;\n    return source[key];\n}\nfunction isEqual(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    else {\n        return x !== x && y !== y;\n    }\n}\nfunction revokeProxy(proxyDraft) {\n    if (!proxyDraft)\n        return;\n    while (proxyDraft.finalities.revoke.length > 0) {\n        const revoke = proxyDraft.finalities.revoke.pop();\n        revoke();\n    }\n}\n// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901\nfunction escapePath(path, pathAsArray) {\n    return pathAsArray\n        ? path\n        : ['']\n            .concat(path)\n            .map((_item) => {\n            const item = `${_item}`;\n            if (item.indexOf('/') === -1 && item.indexOf('~') === -1)\n                return item;\n            return item.replace(/~/g, '~0').replace(/\\//g, '~1');\n        })\n            .join('/');\n}\nfunction unescapePath(path) {\n    if (Array.isArray(path))\n        return path;\n    return path\n        .split('/')\n        .map((_item) => _item.replace(/~1/g, '/').replace(/~0/g, '~'))\n        .slice(1);\n}\nfunction resolvePath(base, path) {\n    for (let index = 0; index < path.length - 1; index += 1) {\n        const key = path[index];\n        // use `index` in Set draft\n        base = get(getType(base) === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\n        if (typeof base !== 'object') {\n            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);\n        }\n    }\n    return base;\n}\n\nfunction strictCopy(target) {\n    const copy = Object.create(Object.getPrototypeOf(target));\n    Reflect.ownKeys(target).forEach((key) => {\n        let desc = Reflect.getOwnPropertyDescriptor(target, key);\n        if (desc.enumerable && desc.configurable && desc.writable) {\n            copy[key] = target[key];\n            return;\n        }\n        // for freeze\n        if (!desc.writable) {\n            desc.writable = true;\n            desc.configurable = true;\n        }\n        if (desc.get || desc.set)\n            desc = {\n                configurable: true,\n                writable: true,\n                enumerable: desc.enumerable,\n                value: target[key],\n            };\n        Reflect.defineProperty(copy, key, desc);\n    });\n    return copy;\n}\nconst propIsEnum = Object.prototype.propertyIsEnumerable;\nfunction shallowCopy(original, options) {\n    let markResult;\n    if (Array.isArray(original)) {\n        return Array.prototype.concat.call(original);\n    }\n    else if (original instanceof Set) {\n        if (!isBaseSetInstance(original)) {\n            const SubClass = Object.getPrototypeOf(original).constructor;\n            return new SubClass(original.values());\n        }\n        return Set.prototype.difference\n            ? Set.prototype.difference.call(original, new Set())\n            : new Set(original.values());\n    }\n    else if (original instanceof Map) {\n        if (!isBaseMapInstance(original)) {\n            const SubClass = Object.getPrototypeOf(original).constructor;\n            return new SubClass(original);\n        }\n        return new Map(original);\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.mark) &&\n        ((markResult = options.mark(original, dataTypes)),\n            markResult !== undefined) &&\n        markResult !== dataTypes.mutable) {\n        if (markResult === dataTypes.immutable) {\n            return strictCopy(original);\n        }\n        else if (typeof markResult === 'function') {\n            if ((options.enablePatches || options.enableAutoFreeze)) {\n                throw new Error(`You can't use mark and patches or auto freeze together.`);\n            }\n            return markResult();\n        }\n        throw new Error(`Unsupported mark result: ${markResult}`);\n    }\n    else if (typeof original === 'object' &&\n        Object.getPrototypeOf(original) === Object.prototype) {\n        // For best performance with shallow copies,\n        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.\n        const copy = {};\n        Object.keys(original).forEach((key) => {\n            copy[key] = original[key];\n        });\n        Object.getOwnPropertySymbols(original).forEach((key) => {\n            if (propIsEnum.call(original, key)) {\n                copy[key] = original[key];\n            }\n        });\n        return copy;\n    }\n    else {\n        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);\n    }\n}\nfunction ensureShallowCopy(target) {\n    if (target.copy)\n        return;\n    target.copy = shallowCopy(target.original, target.options);\n}\nfunction deepClone(target) {\n    if (!isDraftable(target))\n        return getValue(target);\n    if (Array.isArray(target))\n        return target.map(deepClone);\n    if (target instanceof Map) {\n        const iterable = Array.from(target.entries()).map(([k, v]) => [\n            k,\n            deepClone(v),\n        ]);\n        if (!isBaseMapInstance(target)) {\n            const SubClass = Object.getPrototypeOf(target).constructor;\n            return new SubClass(iterable);\n        }\n        return new Map(iterable);\n    }\n    if (target instanceof Set) {\n        const iterable = Array.from(target).map(deepClone);\n        if (!isBaseSetInstance(target)) {\n            const SubClass = Object.getPrototypeOf(target).constructor;\n            return new SubClass(iterable);\n        }\n        return new Set(iterable);\n    }\n    const copy = Object.create(Object.getPrototypeOf(target));\n    for (const key in target)\n        copy[key] = deepClone(target[key]);\n    return copy;\n}\nfunction cloneIfNeeded(target) {\n    return isDraft(target) ? deepClone(target) : target;\n}\n\nfunction markChanged(proxyDraft) {\n    var _a;\n    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n    if (!proxyDraft.operated) {\n        proxyDraft.operated = true;\n        if (proxyDraft.parent) {\n            markChanged(proxyDraft.parent);\n        }\n    }\n}\n\nfunction throwFrozenError() {\n    throw new Error('Cannot modify frozen object');\n}\nfunction deepFreeze(target, subKey, updatedValues, stack, keys) {\n    {\n        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();\n        stack = stack !== null && stack !== void 0 ? stack : [];\n        keys = keys !== null && keys !== void 0 ? keys : [];\n        const value = updatedValues.has(target)\n            ? updatedValues.get(target)\n            : target;\n        if (stack.length > 0) {\n            const index = stack.indexOf(value);\n            if (value && typeof value === 'object' && index !== -1) {\n                if (stack[0] === value) {\n                    throw new Error(`Forbids circular reference`);\n                }\n                throw new Error(`Forbids circular reference: ~/${keys\n                    .slice(0, index)\n                    .map((key, index) => {\n                    if (typeof key === 'symbol')\n                        return `[${key.toString()}]`;\n                    const parent = stack[index];\n                    if (typeof key === 'object' &&\n                        (parent instanceof Map || parent instanceof Set))\n                        return Array.from(parent.keys()).indexOf(key);\n                    return key;\n                })\n                    .join('/')}`);\n            }\n            stack.push(value);\n            keys.push(subKey);\n        }\n        else {\n            stack.push(value);\n        }\n    }\n    if (Object.isFrozen(target) || isDraft(target)) {\n        {\n            stack.pop();\n            keys.pop();\n        }\n        return;\n    }\n    const type = getType(target);\n    switch (type) {\n        case 2 /* DraftType.Map */:\n            for (const [key, value] of target) {\n                deepFreeze(key, key, updatedValues, stack, keys);\n                deepFreeze(value, key, updatedValues, stack, keys);\n            }\n            target.set = target.clear = target.delete = throwFrozenError;\n            break;\n        case 3 /* DraftType.Set */:\n            for (const value of target) {\n                deepFreeze(value, value, updatedValues, stack, keys);\n            }\n            target.add = target.clear = target.delete = throwFrozenError;\n            break;\n        case 1 /* DraftType.Array */:\n            Object.freeze(target);\n            let index = 0;\n            for (const value of target) {\n                deepFreeze(value, index, updatedValues, stack, keys);\n                index += 1;\n            }\n            break;\n        default:\n            Object.freeze(target);\n            // ignore non-enumerable or symbol properties\n            Object.keys(target).forEach((name) => {\n                const value = target[name];\n                deepFreeze(value, name, updatedValues, stack, keys);\n            });\n    }\n    {\n        stack.pop();\n        keys.pop();\n    }\n}\n\nfunction forEach(target, iter) {\n    const type = getType(target);\n    if (type === 0 /* DraftType.Object */) {\n        Reflect.ownKeys(target).forEach((key) => {\n            iter(key, target[key], target);\n        });\n    }\n    else if (type === 1 /* DraftType.Array */) {\n        let index = 0;\n        for (const entry of target) {\n            iter(index, entry, target);\n            index += 1;\n        }\n    }\n    else {\n        target.forEach((entry, index) => iter(index, entry, target));\n    }\n}\n\nfunction handleValue(target, handledSet, options) {\n    if (isDraft(target) ||\n        !isDraftable(target, options) ||\n        handledSet.has(target) ||\n        Object.isFrozen(target))\n        return;\n    const isSet = target instanceof Set;\n    const setMap = isSet ? new Map() : undefined;\n    handledSet.add(target);\n    forEach(target, (key, value) => {\n        var _a;\n        if (isDraft(value)) {\n            const proxyDraft = getProxyDraft(value);\n            ensureShallowCopy(proxyDraft);\n            // A draft where a child node has been changed, or assigned a value\n            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated\n                ? proxyDraft.copy\n                : proxyDraft.original;\n            // final update value\n            set(isSet ? setMap : target, key, updatedValue);\n        }\n        else {\n            handleValue(value, handledSet, options);\n        }\n    });\n    if (setMap) {\n        const set = target;\n        const values = Array.from(set);\n        set.clear();\n        values.forEach((value) => {\n            set.add(setMap.has(value) ? setMap.get(value) : value);\n        });\n    }\n}\nfunction finalizeAssigned(proxyDraft, key) {\n    // handle the draftable assigned valuesï¼Œ and the value is not a draft\n    const copy = proxyDraft.type === 3 /* DraftType.Set */ ? proxyDraft.setMap : proxyDraft.copy;\n    if (proxyDraft.finalities.revoke.length > 1 &&\n        proxyDraft.assignedMap.get(key) &&\n        copy) {\n        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);\n    }\n}\nfunction finalizeSetValue(target) {\n    if (target.type === 3 /* DraftType.Set */ && target.copy) {\n        target.copy.clear();\n        target.setMap.forEach((value) => {\n            target.copy.add(getValue(value));\n        });\n    }\n}\nfunction finalizePatches(target, generatePatches, patches, inversePatches) {\n    const shouldFinalize = target.operated &&\n        target.assignedMap &&\n        target.assignedMap.size > 0 &&\n        !target.finalized;\n    if (shouldFinalize) {\n        if (patches && inversePatches) {\n            const basePath = getPath(target);\n            if (basePath) {\n                generatePatches(target, basePath, patches, inversePatches);\n            }\n        }\n        target.finalized = true;\n    }\n}\nfunction markFinalization(target, key, value, generatePatches) {\n    const proxyDraft = getProxyDraft(value);\n    if (proxyDraft) {\n        // !case: assign the draft value\n        if (!proxyDraft.callbacks) {\n            proxyDraft.callbacks = [];\n        }\n        proxyDraft.callbacks.push((patches, inversePatches) => {\n            var _a;\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            if (isEqual(get(copy, key), value)) {\n                let updatedValue = proxyDraft.original;\n                if (proxyDraft.copy) {\n                    updatedValue = proxyDraft.copy;\n                }\n                finalizeSetValue(target);\n                finalizePatches(target, generatePatches, patches, inversePatches);\n                if (target.options.enableAutoFreeze) {\n                    target.options.updatedValues =\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\n                }\n                // final update value\n                set(copy, key, updatedValue);\n            }\n        });\n        if (target.options.enableAutoFreeze) {\n            // !case: assign the draft value in cross draft tree\n            if (proxyDraft.finalities !== target.finalities) {\n                target.options.enableAutoFreeze = false;\n            }\n        }\n    }\n    if (isDraftable(value, target.options)) {\n        // !case: assign the non-draft value\n        target.finalities.draft.push(() => {\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            if (isEqual(get(copy, key), value)) {\n                finalizeAssigned(target, key);\n            }\n        });\n    }\n}\n\nfunction generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {\n    let { original, assignedMap, options } = proxyState;\n    let copy = proxyState.copy;\n    if (copy.length < original.length) {\n        [original, copy] = [copy, original];\n        [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let index = 0; index < original.length; index += 1) {\n        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Replace,\n                path,\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n                value: cloneIfNeeded(copy[index]),\n            });\n            inversePatches.push({\n                op: Operation.Replace,\n                path,\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n                value: cloneIfNeeded(original[index]),\n            });\n        }\n    }\n    for (let index = original.length; index < copy.length; index += 1) {\n        const _path = basePath.concat([index]);\n        const path = escapePath(_path, pathAsArray);\n        patches.push({\n            op: Operation.Add,\n            path,\n            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n            value: cloneIfNeeded(copy[index]),\n        });\n    }\n    if (original.length < copy.length) {\n        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4\n        // For performance, here we only generate an operation that replaces the length of the array,\n        // which is inconsistent with JSON Patch specification\n        const { arrayLengthAssignment = true } = options.enablePatches;\n        if (arrayLengthAssignment) {\n            const _path = basePath.concat(['length']);\n            const path = escapePath(_path, pathAsArray);\n            inversePatches.push({\n                op: Operation.Replace,\n                path,\n                value: original.length,\n            });\n        }\n        else {\n            for (let index = copy.length; original.length < index; index -= 1) {\n                const _path = basePath.concat([index - 1]);\n                const path = escapePath(_path, pathAsArray);\n                inversePatches.push({\n                    op: Operation.Remove,\n                    path,\n                });\n            }\n        }\n    }\n}\nfunction generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {\n    assignedMap.forEach((assignedValue, key) => {\n        const originalValue = get(original, key);\n        const value = cloneIfNeeded(get(copy, key));\n        const op = !assignedValue\n            ? Operation.Remove\n            : has(original, key)\n                ? Operation.Replace\n                : Operation.Add;\n        if (isEqual(originalValue, value) && op === Operation.Replace)\n            return;\n        const _path = basePath.concat(key);\n        const path = escapePath(_path, pathAsArray);\n        patches.push(op === Operation.Remove ? { op, path } : { op, path, value });\n        inversePatches.push(op === Operation.Add\n            ? { op: Operation.Remove, path }\n            : op === Operation.Remove\n                ? { op: Operation.Add, path, value: originalValue }\n                : { op: Operation.Replace, path, value: originalValue });\n    });\n}\nfunction generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {\n    let index = 0;\n    original.forEach((value) => {\n        if (!copy.has(value)) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Remove,\n                path,\n                value,\n            });\n            inversePatches.unshift({\n                op: Operation.Add,\n                path,\n                value,\n            });\n        }\n        index += 1;\n    });\n    index = 0;\n    copy.forEach((value) => {\n        if (!original.has(value)) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Add,\n                path,\n                value,\n            });\n            inversePatches.unshift({\n                op: Operation.Remove,\n                path,\n                value,\n            });\n        }\n        index += 1;\n    });\n}\nfunction generatePatches(proxyState, basePath, patches, inversePatches) {\n    const { pathAsArray = true } = proxyState.options.enablePatches;\n    switch (proxyState.type) {\n        case 0 /* DraftType.Object */:\n        case 2 /* DraftType.Map */:\n            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);\n        case 1 /* DraftType.Array */:\n            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n        case 3 /* DraftType.Set */:\n            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n    }\n}\n\nlet readable = false;\nconst checkReadable = (value, options, ignoreCheckDraftable = false) => {\n    if (typeof value === 'object' &&\n        value !== null &&\n        (!isDraftable(value, options) || ignoreCheckDraftable) &&\n        !readable) {\n        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);\n    }\n};\n/**\n * `unsafe(callback)` to access mutable data directly in strict mode.\n *\n * ## Example\n *\n * ```ts\n * import { create, unsafe } from '../index';\n *\n * class Foobar {\n *   bar = 1;\n * }\n *\n * const baseState = { foobar: new Foobar() };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *    unsafe(() => {\n *      draft.foobar.bar = 2;\n *    });\n *   },\n *   {\n *     strict: true,\n *   }\n * );\n *\n * expect(state).toBe(baseState);\n * expect(state.foobar).toBe(baseState.foobar);\n * expect(state.foobar.bar).toBe(2);\n * ```\n */\nfunction unsafe(callback) {\n    readable = true;\n    let result;\n    try {\n        result = callback();\n    }\n    finally {\n        readable = false;\n    }\n    return result;\n}\n\nconst mapHandler = {\n    get size() {\n        const current = latest(getProxyDraft(this));\n        return current.size;\n    },\n    has(key) {\n        return latest(getProxyDraft(this)).has(key);\n    },\n    set(key, value) {\n        const target = getProxyDraft(this);\n        const source = latest(target);\n        if (!source.has(key) || !isEqual(source.get(key), value)) {\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(key, true);\n            target.copy.set(key, value);\n            markFinalization(target, key, value, generatePatches);\n        }\n        return this;\n    },\n    delete(key) {\n        if (!this.has(key)) {\n            return false;\n        }\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        if (target.original.has(key)) {\n            target.assignedMap.set(key, false);\n        }\n        else {\n            target.assignedMap.delete(key);\n        }\n        target.copy.delete(key);\n        return true;\n    },\n    clear() {\n        const target = getProxyDraft(this);\n        if (!this.size)\n            return;\n        ensureShallowCopy(target);\n        markChanged(target);\n        target.assignedMap = new Map();\n        for (const [key] of target.original) {\n            target.assignedMap.set(key, false);\n        }\n        target.copy.clear();\n    },\n    forEach(callback, thisArg) {\n        const target = getProxyDraft(this);\n        latest(target).forEach((_value, _key) => {\n            callback.call(thisArg, this.get(_key), _key, this);\n        });\n    },\n    get(key) {\n        var _a, _b;\n        const target = getProxyDraft(this);\n        const value = latest(target).get(key);\n        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n        if (target.options.strict) {\n            checkReadable(value, target.options, mutable);\n        }\n        if (mutable) {\n            return value;\n        }\n        if (target.finalized || !isDraftable(value, target.options)) {\n            return value;\n        }\n        // drafted or reassigned\n        if (value !== target.original.get(key)) {\n            return value;\n        }\n        const draft = internal.createDraft({\n            original: value,\n            parentDraft: target,\n            key,\n            finalities: target.finalities,\n            options: target.options,\n        });\n        ensureShallowCopy(target);\n        target.copy.set(key, draft);\n        return draft;\n    },\n    keys() {\n        return latest(getProxyDraft(this)).keys();\n    },\n    values() {\n        const iterator = this.keys();\n        return {\n            [iteratorSymbol]: () => this.values(),\n            next: () => {\n                const result = iterator.next();\n                if (result.done)\n                    return result;\n                const value = this.get(result.value);\n                return {\n                    done: false,\n                    value,\n                };\n            },\n        };\n    },\n    entries() {\n        const iterator = this.keys();\n        return {\n            [iteratorSymbol]: () => this.entries(),\n            next: () => {\n                const result = iterator.next();\n                if (result.done)\n                    return result;\n                const value = this.get(result.value);\n                return {\n                    done: false,\n                    value: [result.value, value],\n                };\n            },\n        };\n    },\n    [iteratorSymbol]() {\n        return this.entries();\n    },\n};\nconst mapHandlerKeys = Reflect.ownKeys(mapHandler);\n\nconst getNextIterator = (target, iterator, { isValuesIterator }) => () => {\n    var _a, _b;\n    const result = iterator.next();\n    if (result.done)\n        return result;\n    const key = result.value;\n    let value = target.setMap.get(key);\n    const currentDraft = getProxyDraft(value);\n    const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n    if (target.options.strict) {\n        checkReadable(key, target.options, mutable);\n    }\n    if (!mutable &&\n        !currentDraft &&\n        isDraftable(key, target.options) &&\n        !target.finalized &&\n        target.original.has(key)) {\n        // draft a draftable original set item\n        const proxy = internal.createDraft({\n            original: key,\n            parentDraft: target,\n            key,\n            finalities: target.finalities,\n            options: target.options,\n        });\n        target.setMap.set(key, proxy);\n        value = proxy;\n    }\n    else if (currentDraft) {\n        // drafted\n        value = currentDraft.proxy;\n    }\n    return {\n        done: false,\n        value: isValuesIterator ? value : [value, value],\n    };\n};\nconst setHandler = {\n    get size() {\n        const target = getProxyDraft(this);\n        return target.setMap.size;\n    },\n    has(value) {\n        const target = getProxyDraft(this);\n        // reassigned or non-draftable values\n        if (target.setMap.has(value))\n            return true;\n        ensureShallowCopy(target);\n        const valueProxyDraft = getProxyDraft(value);\n        // drafted\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original))\n            return true;\n        return false;\n    },\n    add(value) {\n        const target = getProxyDraft(this);\n        if (!this.has(value)) {\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(value, true);\n            target.setMap.set(value, value);\n            markFinalization(target, value, value, generatePatches);\n        }\n        return this;\n    },\n    delete(value) {\n        if (!this.has(value)) {\n            return false;\n        }\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        const valueProxyDraft = getProxyDraft(value);\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {\n            // delete drafted\n            target.assignedMap.set(valueProxyDraft.original, false);\n            return target.setMap.delete(valueProxyDraft.original);\n        }\n        if (!valueProxyDraft && target.setMap.has(value)) {\n            // non-draftable values\n            target.assignedMap.set(value, false);\n        }\n        else {\n            // reassigned\n            target.assignedMap.delete(value);\n        }\n        // delete reassigned or non-draftable values\n        return target.setMap.delete(value);\n    },\n    clear() {\n        if (!this.size)\n            return;\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        for (const value of target.original) {\n            target.assignedMap.set(value, false);\n        }\n        target.setMap.clear();\n    },\n    values() {\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        const iterator = target.setMap.keys();\n        return {\n            [Symbol.iterator]: () => this.values(),\n            next: getNextIterator(target, iterator, { isValuesIterator: true }),\n        };\n    },\n    entries() {\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        const iterator = target.setMap.keys();\n        return {\n            [Symbol.iterator]: () => this.entries(),\n            next: getNextIterator(target, iterator, {\n                isValuesIterator: false,\n            }),\n        };\n    },\n    keys() {\n        return this.values();\n    },\n    [iteratorSymbol]() {\n        return this.values();\n    },\n    forEach(callback, thisArg) {\n        const iterator = this.values();\n        let result = iterator.next();\n        while (!result.done) {\n            callback.call(thisArg, result.value, result.value, this);\n            result = iterator.next();\n        }\n    },\n};\nif (Set.prototype.difference) {\n    // for compatibility with new Set methods\n    // https://github.com/tc39/proposal-set-methods\n    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.\n    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.\n    Object.assign(setHandler, {\n        intersection(other) {\n            return Set.prototype.intersection.call(new Set(this.values()), other);\n        },\n        union(other) {\n            return Set.prototype.union.call(new Set(this.values()), other);\n        },\n        difference(other) {\n            return Set.prototype.difference.call(new Set(this.values()), other);\n        },\n        symmetricDifference(other) {\n            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);\n        },\n        isSubsetOf(other) {\n            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);\n        },\n        isSupersetOf(other) {\n            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);\n        },\n        isDisjointFrom(other) {\n            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);\n        },\n    });\n}\nconst setHandlerKeys = Reflect.ownKeys(setHandler);\n\nconst draftsCache = new WeakSet();\nconst proxyHandler = {\n    get(target, key, receiver) {\n        var _a, _b;\n        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];\n        // Improve draft reading performance by caching the draft copy.\n        if (copy && draftsCache.has(copy)) {\n            return copy;\n        }\n        if (key === PROXY_DRAFT)\n            return target;\n        let markResult;\n        if (target.options.mark) {\n            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`\n            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`\n            const value = key === 'size' &&\n                (target.original instanceof Map || target.original instanceof Set)\n                ? Reflect.get(target.original, key)\n                : Reflect.get(target.original, key, receiver);\n            markResult = target.options.mark(value, dataTypes);\n            if (markResult === dataTypes.mutable) {\n                if (target.options.strict) {\n                    checkReadable(value, target.options, true);\n                }\n                return value;\n            }\n        }\n        const source = latest(target);\n        if (source instanceof Map && mapHandlerKeys.includes(key)) {\n            if (key === 'size') {\n                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);\n            }\n            const handle = mapHandler[key];\n            if (handle) {\n                return handle.bind(target.proxy);\n            }\n        }\n        if (source instanceof Set && setHandlerKeys.includes(key)) {\n            if (key === 'size') {\n                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);\n            }\n            const handle = setHandler[key];\n            if (handle) {\n                return handle.bind(target.proxy);\n            }\n        }\n        if (!has(source, key)) {\n            const desc = getDescriptor(source, key);\n            return desc\n                ? `value` in desc\n                    ? desc.value\n                    : // !case: support for getter\n                        (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy)\n                : undefined;\n        }\n        const value = source[key];\n        if (target.options.strict) {\n            checkReadable(value, target.options);\n        }\n        if (target.finalized || !isDraftable(value, target.options)) {\n            return value;\n        }\n        // Ensure that the assigned values are not drafted\n        if (value === peek(target.original, key)) {\n            ensureShallowCopy(target);\n            target.copy[key] = createDraft({\n                original: target.original[key],\n                parentDraft: target,\n                key: target.type === 1 /* DraftType.Array */ ? Number(key) : key,\n                finalities: target.finalities,\n                options: target.options,\n            });\n            // !case: support for custom shallow copy function\n            if (typeof markResult === 'function') {\n                const subProxyDraft = getProxyDraft(target.copy[key]);\n                ensureShallowCopy(subProxyDraft);\n                // Trigger a custom shallow copy to update to a new copy\n                markChanged(subProxyDraft);\n                return subProxyDraft.copy;\n            }\n            return target.copy[key];\n        }\n        return value;\n    },\n    set(target, key, value) {\n        var _a;\n        if (target.type === 3 /* DraftType.Set */ || target.type === 2 /* DraftType.Map */) {\n            throw new Error(`Map/Set draft does not support any property assignment.`);\n        }\n        let _key;\n        if (target.type === 1 /* DraftType.Array */ &&\n            key !== 'length' &&\n            !(Number.isInteger((_key = Number(key))) &&\n                _key >= 0 &&\n                (key === 0 || _key === 0 || String(_key) === String(key)))) {\n            throw new Error(`Only supports setting array indices and the 'length' property.`);\n        }\n        const desc = getDescriptor(latest(target), key);\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\n            // !case: cover the case of setter\n            desc.set.call(target.proxy, value);\n            return true;\n        }\n        const current = peek(latest(target), key);\n        const currentProxyDraft = getProxyDraft(current);\n        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {\n            // !case: ignore the case of assigning the original draftable value to a draft\n            target.copy[key] = value;\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n            target.assignedMap.set(key, false);\n            return true;\n        }\n        // !case: handle new props with value 'undefined'\n        if (isEqual(value, current) &&\n            (value !== undefined || has(target.original, key)))\n            return true;\n        ensureShallowCopy(target);\n        markChanged(target);\n        if (has(target.original, key) && isEqual(value, target.original[key])) {\n            // !case: handle the case of assigning the original non-draftable value to a draft\n            target.assignedMap.delete(key);\n        }\n        else {\n            target.assignedMap.set(key, true);\n        }\n        target.copy[key] = value;\n        markFinalization(target, key, value, generatePatches);\n        return true;\n    },\n    has(target, key) {\n        return key in latest(target);\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(latest(target));\n    },\n    getOwnPropertyDescriptor(target, key) {\n        const source = latest(target);\n        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\n        if (!descriptor)\n            return descriptor;\n        return {\n            writable: true,\n            configurable: target.type !== 1 /* DraftType.Array */ || key !== 'length',\n            enumerable: descriptor.enumerable,\n            value: source[key],\n        };\n    },\n    getPrototypeOf(target) {\n        return Reflect.getPrototypeOf(target.original);\n    },\n    setPrototypeOf() {\n        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);\n    },\n    defineProperty() {\n        throw new Error(`Cannot call 'defineProperty()' on drafts`);\n    },\n    deleteProperty(target, key) {\n        var _a;\n        if (target.type === 1 /* DraftType.Array */) {\n            return proxyHandler.set.call(this, target, key, undefined, target.proxy);\n        }\n        if (peek(target.original, key) !== undefined || key in target.original) {\n            // !case: delete an existing key\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(key, false);\n        }\n        else {\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n            // The original non-existent key has been deleted\n            target.assignedMap.delete(key);\n        }\n        if (target.copy)\n            delete target.copy[key];\n        return true;\n    },\n};\nfunction createDraft(createDraftOptions) {\n    const { original, parentDraft, key, finalities, options } = createDraftOptions;\n    const type = getType(original);\n    const proxyDraft = {\n        type,\n        finalized: false,\n        parent: parentDraft,\n        original,\n        copy: null,\n        proxy: null,\n        finalities,\n        options,\n        // Mapping of draft Set items to their corresponding draft values.\n        setMap: type === 3 /* DraftType.Set */\n            ? new Map(original.entries())\n            : undefined,\n    };\n    // !case: undefined as a draft map key\n    if (key || 'key' in createDraftOptions) {\n        proxyDraft.key = key;\n    }\n    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */ ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);\n    finalities.revoke.push(revoke);\n    draftsCache.add(proxy);\n    proxyDraft.proxy = proxy;\n    if (parentDraft) {\n        const target = parentDraft;\n        target.finalities.draft.push((patches, inversePatches) => {\n            var _a, _b;\n            const oldProxyDraft = getProxyDraft(proxy);\n            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.\n            let copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            const draft = get(copy, key);\n            const proxyDraft = getProxyDraft(draft);\n            if (proxyDraft) {\n                // assign the updated value to the copy object\n                let updatedValue = proxyDraft.original;\n                if (proxyDraft.operated) {\n                    updatedValue = getValue(draft);\n                }\n                finalizeSetValue(proxyDraft);\n                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);\n                if (target.options.enableAutoFreeze) {\n                    target.options.updatedValues =\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\n                }\n                // final update value\n                set(copy, key, updatedValue);\n            }\n            // !case: handle the deleted key\n            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback) => {\n                callback(patches, inversePatches);\n            });\n        });\n    }\n    else {\n        // !case: handle the root draft\n        const target = getProxyDraft(proxy);\n        target.finalities.draft.push((patches, inversePatches) => {\n            finalizeSetValue(target);\n            finalizePatches(target, generatePatches, patches, inversePatches);\n        });\n    }\n    return proxy;\n}\ninternal.createDraft = createDraft;\nfunction finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {\n    var _a;\n    const proxyDraft = getProxyDraft(result);\n    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;\n    const hasReturnedValue = !!returnedValue.length;\n    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {\n        while (proxyDraft.finalities.draft.length > 0) {\n            const finalize = proxyDraft.finalities.draft.pop();\n            finalize(patches, inversePatches);\n        }\n    }\n    const state = hasReturnedValue\n        ? returnedValue[0]\n        : proxyDraft\n            ? proxyDraft.operated\n                ? proxyDraft.copy\n                : proxyDraft.original\n            : result;\n    if (proxyDraft)\n        revokeProxy(proxyDraft);\n    if (enableAutoFreeze) {\n        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);\n    }\n    return [\n        state,\n        patches && hasReturnedValue\n            ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }]\n            : patches,\n        inversePatches && hasReturnedValue\n            ? [{ op: Operation.Replace, path: [], value: original }]\n            : inversePatches,\n    ];\n}\n\nfunction draftify(baseState, options) {\n    var _a;\n    const finalities = {\n        draft: [],\n        revoke: [],\n        handledSet: new WeakSet(),\n    };\n    let patches;\n    let inversePatches;\n    if (options.enablePatches) {\n        patches = [];\n        inversePatches = [];\n    }\n    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable ||\n        !isDraftable(baseState, options);\n    const draft = isMutable\n        ? baseState\n        : createDraft({\n            original: baseState,\n            parentDraft: null,\n            finalities,\n            options,\n        });\n    return [\n        draft,\n        (returnedValue = []) => {\n            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);\n            return (options.enablePatches\n                ? [finalizedState, finalizedPatches, finalizedInversePatches]\n                : finalizedState);\n        },\n    ];\n}\n\nfunction handleReturnValue(options) {\n    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;\n    forEach(value, (key, item, source) => {\n        const proxyDraft = getProxyDraft(item);\n        // just handle the draft which is created by the same rootDraft\n        if (proxyDraft &&\n            rootDraft &&\n            proxyDraft.finalities === rootDraft.finalities) {\n            options.isContainDraft = true;\n            const currentValue = proxyDraft.original;\n            // final update value, but just handle return value\n            if (source instanceof Set) {\n                const arr = Array.from(source);\n                source.clear();\n                arr.forEach((_item) => source.add(key === _item ? currentValue : _item));\n            }\n            else {\n                set(source, key, currentValue);\n            }\n        }\n        else if (typeof item === 'object' && item !== null) {\n            options.value = item;\n            options.isRoot = false;\n            handleReturnValue(options);\n        }\n    });\n    if (isRoot) {\n        if (!options.isContainDraft)\n            console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);\n        if (useRawReturn) {\n            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);\n        }\n    }\n}\nfunction getCurrent(target) {\n    var _a;\n    const proxyDraft = getProxyDraft(target);\n    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options))\n        return target;\n    const type = getType(target);\n    if (proxyDraft && !proxyDraft.operated)\n        return proxyDraft.original;\n    let currentValue;\n    function ensureShallowCopy() {\n        currentValue =\n            type === 2 /* DraftType.Map */\n                ? !isBaseMapInstance(target)\n                    ? new (Object.getPrototypeOf(target).constructor)(target)\n                    : new Map(target)\n                : type === 3 /* DraftType.Set */\n                    ? Array.from(proxyDraft.setMap.values())\n                    : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);\n    }\n    if (proxyDraft) {\n        // It's a proxy draft, let's create a shallow copy eagerly\n        proxyDraft.finalized = true;\n        try {\n            ensureShallowCopy();\n        }\n        finally {\n            proxyDraft.finalized = false;\n        }\n    }\n    else {\n        // It's not a proxy draft, let's use the target directly and let's see\n        // lazily if we need to create a shallow copy\n        currentValue = target;\n    }\n    forEach(currentValue, (key, value) => {\n        if (proxyDraft && isEqual(get(proxyDraft.original, key), value))\n            return;\n        const newValue = getCurrent(value);\n        if (newValue !== value) {\n            if (currentValue === target)\n                ensureShallowCopy();\n            set(currentValue, key, newValue);\n        }\n    });\n    if (type === 3 /* DraftType.Set */) {\n        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;\n        return !isBaseSetInstance(value)\n            ? new (Object.getPrototypeOf(value).constructor)(currentValue)\n            : new Set(currentValue);\n    }\n    return currentValue;\n}\nfunction current(target) {\n    if (!isDraft(target)) {\n        throw new Error(`current() is only used for Draft, parameter: ${target}`);\n    }\n    return getCurrent(target);\n}\n\n/**\n * `makeCreator(options)` to make a creator function.\n *\n * ## Example\n *\n * ```ts\n * import { makeCreator } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const create = makeCreator({ enableAutoFreeze: true });\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * expect(Object.isFrozen(state)).toBeTruthy();\n * ```\n */\nconst makeCreator = (arg) => {\n    if (arg !== undefined &&\n        Object.prototype.toString.call(arg) !== '[object Object]') {\n        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);\n    }\n    return function create(arg0, arg1, arg2) {\n        var _a, _b, _c;\n        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {\n            return function (base, ...args) {\n                return create(base, (draft) => arg0.call(this, draft, ...args), arg1);\n            };\n        }\n        const base = arg0;\n        const mutate = arg1;\n        let options = arg2;\n        if (typeof arg1 !== 'function') {\n            options = arg1;\n        }\n        if (options !== undefined &&\n            Object.prototype.toString.call(options) !== '[object Object]') {\n            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);\n        }\n        options = Object.assign(Object.assign({}, arg), options);\n        const state = isDraft(base) ? current(base) : base;\n        const mark = Array.isArray(options.mark)\n            ? ((value, types) => {\n                for (const mark of options.mark) {\n                    if (typeof mark !== 'function') {\n                        throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);\n                    }\n                    const result = mark(value, types);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return;\n            })\n            : options.mark;\n        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;\n        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;\n        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;\n        const _options = {\n            enableAutoFreeze,\n            mark,\n            strict,\n            enablePatches,\n        };\n        if (!isDraftable(state, _options) &&\n            typeof state === 'object' &&\n            state !== null) {\n            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\n        }\n        const [draft, finalize] = draftify(state, _options);\n        if (typeof arg1 !== 'function') {\n            if (!isDraftable(state, _options)) {\n                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\n            }\n            return [draft, finalize];\n        }\n        let result;\n        try {\n            result = mutate(draft);\n        }\n        catch (error) {\n            revokeProxy(getProxyDraft(draft));\n            throw error;\n        }\n        const returnValue = (value) => {\n            const proxyDraft = getProxyDraft(draft);\n            if (!isDraft(value)) {\n                if (value !== undefined &&\n                    !isEqual(value, draft) &&\n                    (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {\n                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);\n                }\n                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];\n                if (rawReturnValue) {\n                    const _value = rawReturnValue[0];\n                    if (_options.strict && typeof value === 'object' && value !== null) {\n                        handleReturnValue({\n                            rootDraft: proxyDraft,\n                            value,\n                            useRawReturn: true,\n                        });\n                    }\n                    return finalize([_value]);\n                }\n                if (value !== undefined) {\n                    if (typeof value === 'object' && value !== null) {\n                        handleReturnValue({ rootDraft: proxyDraft, value });\n                    }\n                    return finalize([value]);\n                }\n            }\n            if (value === draft || value === undefined) {\n                return finalize([]);\n            }\n            const returnedProxyDraft = getProxyDraft(value);\n            if (_options === returnedProxyDraft.options) {\n                if (returnedProxyDraft.operated) {\n                    throw new Error(`Cannot return a modified child draft.`);\n                }\n                return finalize([current(value)]);\n            }\n            return finalize([value]);\n        };\n        if (result instanceof Promise) {\n            return result.then(returnValue, (error) => {\n                revokeProxy(getProxyDraft(draft));\n                throw error;\n            });\n        }\n        return returnValue(result);\n    };\n};\n\n/**\n * `create(baseState, callback, options)` to create the next state\n *\n * ## Example\n *\n * ```ts\n * import { create } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * ```\n */\nconst create = makeCreator();\n\n/**\n * `apply(state, patches)` to apply patches to state\n *\n * ## Example\n *\n * ```ts\n * import { create, apply } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const [state, patches] = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n *   { enablePatches: true }\n * );\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);\n * expect(state).toEqual(apply(baseState, patches));\n * ```\n */\nfunction apply(state, patches, applyOptions) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i -= 1) {\n        const { value, op, path } = patches[i];\n        if ((!path.length && op === Operation.Replace) ||\n            (path === '' && op === Operation.Add)) {\n            state = value;\n            break;\n        }\n    }\n    if (i > -1) {\n        patches = patches.slice(i + 1);\n    }\n    const mutate = (draft) => {\n        patches.forEach((patch) => {\n            const { path: _path, op } = patch;\n            const path = unescapePath(_path);\n            let base = draft;\n            for (let index = 0; index < path.length - 1; index += 1) {\n                const parentType = getType(base);\n                let key = path[index];\n                if (typeof key !== 'string' && typeof key !== 'number') {\n                    key = String(key);\n                }\n                if (((parentType === 0 /* DraftType.Object */ ||\n                    parentType === 1 /* DraftType.Array */) &&\n                    (key === '__proto__' || key === 'constructor')) ||\n                    (typeof base === 'function' && key === 'prototype')) {\n                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);\n                }\n                // use `index` in Set draft\n                base = get(parentType === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\n                if (typeof base !== 'object') {\n                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);\n                }\n            }\n            const type = getType(base);\n            // ensure the original patch is not modified.\n            const value = deepClone(patch.value);\n            const key = path[path.length - 1];\n            switch (op) {\n                case Operation.Replace:\n                    switch (type) {\n                        case 2 /* DraftType.Map */:\n                            return base.set(key, value);\n                        case 3 /* DraftType.Set */:\n                            throw new Error(`Cannot apply replace patch to set.`);\n                        default:\n                            return (base[key] = value);\n                    }\n                case Operation.Add:\n                    switch (type) {\n                        case 1 /* DraftType.Array */:\n                            // If the \"-\" character is used to\n                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),\n                            // this has the effect of appending the value to the array.\n                            return key === '-'\n                                ? base.push(value)\n                                : base.splice(key, 0, value);\n                        case 2 /* DraftType.Map */:\n                            return base.set(key, value);\n                        case 3 /* DraftType.Set */:\n                            return base.add(value);\n                        default:\n                            return (base[key] = value);\n                    }\n                case Operation.Remove:\n                    switch (type) {\n                        case 1 /* DraftType.Array */:\n                            return base.splice(key, 1);\n                        case 2 /* DraftType.Map */:\n                            return base.delete(key);\n                        case 3 /* DraftType.Set */:\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    throw new Error(`Unsupported patch operation: ${op}.`);\n            }\n        });\n    };\n    if (isDraft(state)) {\n        if (applyOptions !== undefined) {\n            throw new Error(`Cannot apply patches with options to a draft.`);\n        }\n        mutate(state);\n        return state;\n    }\n    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), { enablePatches: false }));\n}\n\n/**\n * `original(draft)` to get original state in the draft mutation function.\n *\n * ## Example\n *\n * ```ts\n * import { create, original } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *     expect(original(draft.foo)).toEqual({ bar: 'str' });\n *   }\n * );\n * ```\n */\nfunction original(target) {\n    const proxyDraft = getProxyDraft(target);\n    if (!proxyDraft) {\n        throw new Error(`original() is only used for a draft, parameter: ${target}`);\n    }\n    return proxyDraft.original;\n}\n\n/**\n * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.\n *\n * ## Example\n *\n * ```ts\n * import { create, rawReturn } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     return rawReturn(baseState);\n *   },\n * );\n * expect(state).toBe(baseState);\n * ```\n */\nfunction rawReturn(value) {\n    if (arguments.length === 0) {\n        throw new Error('rawReturn() must be called with a value.');\n    }\n    if (arguments.length > 1) {\n        throw new Error('rawReturn() must be called with one argument.');\n    }\n    if (value !== undefined &&\n        (typeof value !== 'object' || value === null)) {\n        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');\n    }\n    return {\n        [RAW_RETURN_SYMBOL]: [value],\n    };\n}\n\nconst constructorString = Object.prototype.constructor.toString();\n/**\n * Check if the value is a simple object(No prototype chain object or iframe same-origin object),\n * support case: https://github.com/unadlib/mutative/issues/17\n */\nconst isSimpleObject = (value) => {\n    if (!value || typeof value !== 'object')\n        return false;\n    const prototype = Object.getPrototypeOf(value);\n    if (prototype === null) {\n        return true;\n    }\n    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') &&\n        prototype.constructor;\n    if (constructor === Object)\n        return true;\n    return (typeof constructor === 'function' &&\n        Function.toString.call(constructor) === constructorString);\n};\nconst markSimpleObject = (value) => {\n    if (isSimpleObject(value)) {\n        return dataTypes.immutable;\n    }\n    return;\n};\n\n/**\n * Cast a value to an Draft type value.\n */\nfunction castDraft(value) {\n    return value;\n}\n/**\n * Cast a value to an Immutable type value.\n */\nfunction castImmutable(value) {\n    return value;\n}\n/**\n * Cast a value to an Mutable type value.\n */\nfunction castMutable(draft) {\n    return draft;\n}\n\n\n//# sourceMappingURL=mutative.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXV0YXRpdmUvZGlzdC9tdXRhdGl2ZS5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVyxJQUFJLGlCQUFpQjtBQUNqRjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0IsbURBQW1EO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGtEQUFrRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQTBEO0FBQzNFO0FBQ0E7QUFDQSxpQkFBaUIsa0RBQWtEO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsT0FBTztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0EsdUJBQXVCLE9BQU8sWUFBWTtBQUMxQyxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4QkFBOEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSx1QkFBdUIsT0FBTyxZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsdUJBQXVCLE9BQU8sWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixPQUFPO0FBQ1A7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLFdBQVc7QUFDMUQsOEJBQThCLG9EQUFvRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekMsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGVBQWU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxHQUFHO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsbUJBQW1CLHNCQUFzQjtBQUN4Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLHVCQUF1QixPQUFPLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBLHVCQUF1QixPQUFPLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUySjtBQUMzSiIsInNvdXJjZXMiOlsiRjpcXE5ldyBmb2xkZXJcXGNoYXQtc3R5bGUtZW1haWwtbWFpblxcbm9kZV9tb2R1bGVzXFxtdXRhdGl2ZVxcZGlzdFxcbXV0YXRpdmUuZXNtLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBPcGVyYXRpb24gPSB7XG4gICAgUmVtb3ZlOiAncmVtb3ZlJyxcbiAgICBSZXBsYWNlOiAncmVwbGFjZScsXG4gICAgQWRkOiAnYWRkJyxcbn07XG5cbi8vIERvbid0IHVzZSBgU3ltYm9sKClgIGp1c3QgZm9yIDNyZCBwYXJ0eSBhY2Nlc3MgdGhlIGRyYWZ0XG5jb25zdCBQUk9YWV9EUkFGVCA9IFN5bWJvbC5mb3IoJ19fTVVUQVRJVkVfUFJPWFlfRFJBRlRfXycpO1xuY29uc3QgUkFXX1JFVFVSTl9TWU1CT0wgPSBTeW1ib2woJ19fTVVUQVRJVkVfUkFXX1JFVFVSTl9TWU1CT0xfXycpO1xuY29uc3QgaXRlcmF0b3JTeW1ib2wgPSBTeW1ib2wuaXRlcmF0b3I7XG5jb25zdCBkYXRhVHlwZXMgPSB7XG4gICAgbXV0YWJsZTogJ211dGFibGUnLFxuICAgIGltbXV0YWJsZTogJ2ltbXV0YWJsZScsXG59O1xuXG5jb25zdCBpbnRlcm5hbCA9IHt9O1xuXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgTWFwXG4gICAgICAgID8gdGFyZ2V0LmhhcyhrZXkpXG4gICAgICAgIDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KTtcbn1cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICBsZXQgcHJvdG90eXBlID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICB3aGlsZSAocHJvdG90eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBrZXkpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICBwcm90b3R5cGUgPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gaXNCYXNlU2V0SW5zdGFuY2Uob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTZXQucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gaXNCYXNlTWFwSW5zdGFuY2Uob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBNYXAucHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBsYXRlc3QocHJveHlEcmFmdCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gcHJveHlEcmFmdC5jb3B5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm94eURyYWZ0Lm9yaWdpbmFsO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgYSBkcmFmdFxuICovXG5mdW5jdGlvbiBpc0RyYWZ0KHRhcmdldCkge1xuICAgIHJldHVybiAhIWdldFByb3h5RHJhZnQodGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGdldFByb3h5RHJhZnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVtQUk9YWV9EUkFGVF07XG59XG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHByb3h5RHJhZnQgPyAoX2EgPSBwcm94eURyYWZ0LmNvcHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHByb3h5RHJhZnQub3JpZ2luYWwgOiB2YWx1ZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBkcmFmdGFibGVcbiAqL1xuZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbWFya1Jlc3VsdDtcbiAgICByZXR1cm4gKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBTZXQgfHxcbiAgICAgICAgKCEhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXJrKSAmJlxuICAgICAgICAgICAgKChtYXJrUmVzdWx0ID0gb3B0aW9ucy5tYXJrKHZhbHVlLCBkYXRhVHlwZXMpKSA9PT0gZGF0YVR5cGVzLmltbXV0YWJsZSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBtYXJrUmVzdWx0ID09PSAnZnVuY3Rpb24nKSkpO1xufVxuZnVuY3Rpb24gZ2V0UGF0aCh0YXJnZXQsIHBhdGggPSBbXSkge1xuICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsICdrZXknKSkge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcGFyZW50IGlzIGEgZHJhZnQgYW5kIHRoZSBvcmlnaW5hbCB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgY29uc3QgcGFyZW50Q29weSA9IHRhcmdldC5wYXJlbnQuY29weTtcbiAgICAgICAgY29uc3QgcHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQoZ2V0KHBhcmVudENvcHksIHRhcmdldC5rZXkpKTtcbiAgICAgICAgaWYgKHByb3h5RHJhZnQgIT09IG51bGwgJiYgKHByb3h5RHJhZnQgPT09IG51bGwgfHwgcHJveHlEcmFmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJveHlEcmFmdC5vcmlnaW5hbCkgIT09IHRhcmdldC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTZXQgPSB0YXJnZXQucGFyZW50LnR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLztcbiAgICAgICAgY29uc3Qga2V5ID0gaXNTZXRcbiAgICAgICAgICAgID8gQXJyYXkuZnJvbSh0YXJnZXQucGFyZW50LnNldE1hcC5rZXlzKCkpLmluZGV4T2YodGFyZ2V0LmtleSlcbiAgICAgICAgICAgIDogdGFyZ2V0LmtleTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGtleSBpcyBzdGlsbCBpbiB0aGUgbmV4dCBzdGF0ZSBwYXJlbnRcbiAgICAgICAgaWYgKCEoKGlzU2V0ICYmIHBhcmVudENvcHkuc2l6ZSA+IGtleSkgfHwgaGFzKHBhcmVudENvcHksIGtleSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnBhcmVudCkge1xuICAgICAgICByZXR1cm4gZ2V0UGF0aCh0YXJnZXQucGFyZW50LCBwYXRoKTtcbiAgICB9XG4gICAgLy8gYHRhcmdldGAgaXMgcm9vdCBkcmFmdC5cbiAgICBwYXRoLnJldmVyc2UoKTtcbiAgICB0cnkge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcGF0aCBpcyB2YWxpZFxuICAgICAgICByZXNvbHZlUGF0aCh0YXJnZXQuY29weSwgcGF0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGdldFR5cGUodGFyZ2V0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuIDEgLyogRHJhZnRUeXBlLkFycmF5ICovO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgIHJldHVybiAyIC8qIERyYWZ0VHlwZS5NYXAgKi87XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldClcbiAgICAgICAgcmV0dXJuIDMgLyogRHJhZnRUeXBlLlNldCAqLztcbiAgICByZXR1cm4gMCAvKiBEcmFmdFR5cGUuT2JqZWN0ICovO1xufVxuZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGdldFR5cGUodGFyZ2V0KSA9PT0gMiAvKiBEcmFmdFR5cGUuTWFwICovID8gdGFyZ2V0LmdldChrZXkpIDogdGFyZ2V0W2tleV07XG59XG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUodGFyZ2V0KTtcbiAgICBpZiAodHlwZSA9PT0gMiAvKiBEcmFmdFR5cGUuTWFwICovKSB7XG4gICAgICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBlZWsodGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFByb3h5RHJhZnQodGFyZ2V0KTtcbiAgICBjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiB0YXJnZXQ7XG4gICAgcmV0dXJuIHNvdXJjZVtrZXldO1xufVxuZnVuY3Rpb24gaXNFcXVhbCh4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXZva2VQcm94eShwcm94eURyYWZ0KSB7XG4gICAgaWYgKCFwcm94eURyYWZ0KVxuICAgICAgICByZXR1cm47XG4gICAgd2hpbGUgKHByb3h5RHJhZnQuZmluYWxpdGllcy5yZXZva2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXZva2UgPSBwcm94eURyYWZ0LmZpbmFsaXRpZXMucmV2b2tlLnBvcCgpO1xuICAgICAgICByZXZva2UoKTtcbiAgICB9XG59XG4vLyBoYW5kbGUgSlNPTiBQb2ludGVyIHBhdGggd2l0aCBzcGVjIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2OTAxXG5mdW5jdGlvbiBlc2NhcGVQYXRoKHBhdGgsIHBhdGhBc0FycmF5KSB7XG4gICAgcmV0dXJuIHBhdGhBc0FycmF5XG4gICAgICAgID8gcGF0aFxuICAgICAgICA6IFsnJ11cbiAgICAgICAgICAgIC5jb25jYXQocGF0aClcbiAgICAgICAgICAgIC5tYXAoKF9pdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gYCR7X2l0ZW19YDtcbiAgICAgICAgICAgIGlmIChpdGVtLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgaXRlbS5pbmRleE9mKCd+JykgPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignLycpO1xufVxuZnVuY3Rpb24gdW5lc2NhcGVQYXRoKHBhdGgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgcmV0dXJuIHBhdGhcbiAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgLm1hcCgoX2l0ZW0pID0+IF9pdGVtLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKSlcbiAgICAgICAgLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgoYmFzZSwgcGF0aCkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXRoLmxlbmd0aCAtIDE7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGF0aFtpbmRleF07XG4gICAgICAgIC8vIHVzZSBgaW5kZXhgIGluIFNldCBkcmFmdFxuICAgICAgICBiYXNlID0gZ2V0KGdldFR5cGUoYmFzZSkgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLyA/IEFycmF5LmZyb20oYmFzZSkgOiBiYXNlLCBrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIHBhdGNoIGF0ICcke3BhdGguam9pbignLycpfScuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG59XG5cbmZ1bmN0aW9uIHN0cmljdENvcHkodGFyZ2V0KSB7XG4gICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xuICAgIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBsZXQgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKGRlc2MuZW51bWVyYWJsZSAmJiBkZXNjLmNvbmZpZ3VyYWJsZSAmJiBkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgZnJlZXplXG4gICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KVxuICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRba2V5XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoY29weSwga2V5LCBkZXNjKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbn1cbmNvbnN0IHByb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuZnVuY3Rpb24gc2hhbGxvd0NvcHkob3JpZ2luYWwsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFya1Jlc3VsdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChvcmlnaW5hbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9yaWdpbmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGlmICghaXNCYXNlU2V0SW5zdGFuY2Uob3JpZ2luYWwpKSB7XG4gICAgICAgICAgICBjb25zdCBTdWJDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YkNsYXNzKG9yaWdpbmFsLnZhbHVlcygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2V0LnByb3RvdHlwZS5kaWZmZXJlbmNlXG4gICAgICAgICAgICA/IFNldC5wcm90b3R5cGUuZGlmZmVyZW5jZS5jYWxsKG9yaWdpbmFsLCBuZXcgU2V0KCkpXG4gICAgICAgICAgICA6IG5ldyBTZXQob3JpZ2luYWwudmFsdWVzKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmlnaW5hbCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBpZiAoIWlzQmFzZU1hcEluc3RhbmNlKG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgY29uc3QgU3ViQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJDbGFzcyhvcmlnaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXAob3JpZ2luYWwpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcmspICYmXG4gICAgICAgICgobWFya1Jlc3VsdCA9IG9wdGlvbnMubWFyayhvcmlnaW5hbCwgZGF0YVR5cGVzKSksXG4gICAgICAgICAgICBtYXJrUmVzdWx0ICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgIG1hcmtSZXN1bHQgIT09IGRhdGFUeXBlcy5tdXRhYmxlKSB7XG4gICAgICAgIGlmIChtYXJrUmVzdWx0ID09PSBkYXRhVHlwZXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaWN0Q29weShvcmlnaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1hcmtSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucy5lbmFibGVQYXRjaGVzIHx8IG9wdGlvbnMuZW5hYmxlQXV0b0ZyZWV6ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW4ndCB1c2UgbWFyayBhbmQgcGF0Y2hlcyBvciBhdXRvIGZyZWV6ZSB0b2dldGhlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXJrUmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtYXJrIHJlc3VsdDogJHttYXJrUmVzdWx0fWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICdvYmplY3QnICYmXG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgLy8gRm9yIGJlc3QgcGVyZm9ybWFuY2Ugd2l0aCBzaGFsbG93IGNvcGllcyxcbiAgICAgICAgLy8gZG9uJ3QgdXNlIGBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopKTtgIGJ5IGRlZmF1bHQuXG4gICAgICAgIGNvbnN0IGNvcHkgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMob3JpZ2luYWwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29weVtrZXldID0gb3JpZ2luYWxba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3JpZ2luYWwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3BJc0VudW0uY2FsbChvcmlnaW5hbCwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIGNoZWNrIG1hcmsoKSB0byBlbnN1cmUgdGhhdCBpdCBpcyBhIHN0YWJsZSBtYXJrZXIgZHJhZnRhYmxlIGZ1bmN0aW9uLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZVNoYWxsb3dDb3B5KHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuY29weSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC5jb3B5ID0gc2hhbGxvd0NvcHkodGFyZ2V0Lm9yaWdpbmFsLCB0YXJnZXQub3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmUodGFyZ2V0KSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZSh0YXJnZXQpKVxuICAgICAgICByZXR1cm4gZ2V0VmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKVxuICAgICAgICByZXR1cm4gdGFyZ2V0Lm1hcChkZWVwQ2xvbmUpO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgaXRlcmFibGUgPSBBcnJheS5mcm9tKHRhcmdldC5lbnRyaWVzKCkpLm1hcCgoW2ssIHZdKSA9PiBbXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgZGVlcENsb25lKHYpLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKCFpc0Jhc2VNYXBJbnN0YW5jZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBTdWJDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJDbGFzcyhpdGVyYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoaXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhYmxlID0gQXJyYXkuZnJvbSh0YXJnZXQpLm1hcChkZWVwQ2xvbmUpO1xuICAgICAgICBpZiAoIWlzQmFzZVNldEluc3RhbmNlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFN1YkNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YkNsYXNzKGl0ZXJhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNldChpdGVyYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpXG4gICAgICAgIGNvcHlba2V5XSA9IGRlZXBDbG9uZSh0YXJnZXRba2V5XSk7XG4gICAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBjbG9uZUlmTmVlZGVkKHRhcmdldCkge1xuICAgIHJldHVybiBpc0RyYWZ0KHRhcmdldCkgPyBkZWVwQ2xvbmUodGFyZ2V0KSA6IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gbWFya0NoYW5nZWQocHJveHlEcmFmdCkge1xuICAgIHZhciBfYTtcbiAgICBwcm94eURyYWZ0LmFzc2lnbmVkTWFwID0gKF9hID0gcHJveHlEcmFmdC5hc3NpZ25lZE1hcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IE1hcCgpO1xuICAgIGlmICghcHJveHlEcmFmdC5vcGVyYXRlZCkge1xuICAgICAgICBwcm94eURyYWZ0Lm9wZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByb3h5RHJhZnQucGFyZW50KSB7XG4gICAgICAgICAgICBtYXJrQ2hhbmdlZChwcm94eURyYWZ0LnBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRocm93RnJvemVuRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbW9kaWZ5IGZyb3plbiBvYmplY3QnKTtcbn1cbmZ1bmN0aW9uIGRlZXBGcmVlemUodGFyZ2V0LCBzdWJLZXksIHVwZGF0ZWRWYWx1ZXMsIHN0YWNrLCBrZXlzKSB7XG4gICAge1xuICAgICAgICB1cGRhdGVkVmFsdWVzID0gdXBkYXRlZFZhbHVlcyAhPT0gbnVsbCAmJiB1cGRhdGVkVmFsdWVzICE9PSB2b2lkIDAgPyB1cGRhdGVkVmFsdWVzIDogbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgc3RhY2sgPSBzdGFjayAhPT0gbnVsbCAmJiBzdGFjayAhPT0gdm9pZCAwID8gc3RhY2sgOiBbXTtcbiAgICAgICAga2V5cyA9IGtleXMgIT09IG51bGwgJiYga2V5cyAhPT0gdm9pZCAwID8ga2V5cyA6IFtdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHVwZGF0ZWRWYWx1ZXMuaGFzKHRhcmdldClcbiAgICAgICAgICAgID8gdXBkYXRlZFZhbHVlcy5nZXQodGFyZ2V0KVxuICAgICAgICAgICAgOiB0YXJnZXQ7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YWNrLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2U6IH4vJHtrZXlzXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFske2tleS50b1N0cmluZygpfV1gO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBzdGFja1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcmVudCBpbnN0YW5jZW9mIE1hcCB8fCBwYXJlbnQgaW5zdGFuY2VvZiBTZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LmtleXMoKSkuaW5kZXhPZihrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcvJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChzdWJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5pc0Zyb3plbih0YXJnZXQpIHx8IGlzRHJhZnQodGFyZ2V0KSkge1xuICAgICAgICB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGtleXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZSh0YXJnZXQpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDIgLyogRHJhZnRUeXBlLk1hcCAqLzpcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGRlZXBGcmVlemUoa2V5LCBrZXksIHVwZGF0ZWRWYWx1ZXMsIHN0YWNrLCBrZXlzKTtcbiAgICAgICAgICAgICAgICBkZWVwRnJlZXplKHZhbHVlLCBrZXksIHVwZGF0ZWRWYWx1ZXMsIHN0YWNrLCBrZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5zZXQgPSB0YXJnZXQuY2xlYXIgPSB0YXJnZXQuZGVsZXRlID0gdGhyb3dGcm96ZW5FcnJvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogRHJhZnRUeXBlLlNldCAqLzpcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZGVlcEZyZWV6ZSh2YWx1ZSwgdmFsdWUsIHVwZGF0ZWRWYWx1ZXMsIHN0YWNrLCBrZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5hZGQgPSB0YXJnZXQuY2xlYXIgPSB0YXJnZXQuZGVsZXRlID0gdGhyb3dGcm96ZW5FcnJvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogRHJhZnRUeXBlLkFycmF5ICovOlxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0YXJnZXQpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZGVlcEZyZWV6ZSh2YWx1ZSwgaW5kZXgsIHVwZGF0ZWRWYWx1ZXMsIHN0YWNrLCBrZXlzKTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRhcmdldCk7XG4gICAgICAgICAgICAvLyBpZ25vcmUgbm9uLWVudW1lcmFibGUgb3Igc3ltYm9sIHByb3BlcnRpZXNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgIGRlZXBGcmVlemUodmFsdWUsIG5hbWUsIHVwZGF0ZWRWYWx1ZXMsIHN0YWNrLCBrZXlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBrZXlzLnBvcCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh0YXJnZXQsIGl0ZXIpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZSh0YXJnZXQpO1xuICAgIGlmICh0eXBlID09PSAwIC8qIERyYWZ0VHlwZS5PYmplY3QgKi8pIHtcbiAgICAgICAgUmVmbGVjdC5vd25LZXlzKHRhcmdldCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpdGVyKGtleSwgdGFyZ2V0W2tleV0sIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAxIC8qIERyYWZ0VHlwZS5BcnJheSAqLykge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRhcmdldCkge1xuICAgICAgICAgICAgaXRlcihpbmRleCwgZW50cnksIHRhcmdldCk7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQuZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgdGFyZ2V0KSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVWYWx1ZSh0YXJnZXQsIGhhbmRsZWRTZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNEcmFmdCh0YXJnZXQpIHx8XG4gICAgICAgICFpc0RyYWZ0YWJsZSh0YXJnZXQsIG9wdGlvbnMpIHx8XG4gICAgICAgIGhhbmRsZWRTZXQuaGFzKHRhcmdldCkgfHxcbiAgICAgICAgT2JqZWN0LmlzRnJvemVuKHRhcmdldCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBpc1NldCA9IHRhcmdldCBpbnN0YW5jZW9mIFNldDtcbiAgICBjb25zdCBzZXRNYXAgPSBpc1NldCA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgICBoYW5kbGVkU2V0LmFkZCh0YXJnZXQpO1xuICAgIGZvckVhY2godGFyZ2V0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpc0RyYWZ0KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgcHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQodmFsdWUpO1xuICAgICAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkocHJveHlEcmFmdCk7XG4gICAgICAgICAgICAvLyBBIGRyYWZ0IHdoZXJlIGEgY2hpbGQgbm9kZSBoYXMgYmVlbiBjaGFuZ2VkLCBvciBhc3NpZ25lZCBhIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkVmFsdWUgPSAoKF9hID0gcHJveHlEcmFmdC5hc3NpZ25lZE1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemUpIHx8IHByb3h5RHJhZnQub3BlcmF0ZWRcbiAgICAgICAgICAgICAgICA/IHByb3h5RHJhZnQuY29weVxuICAgICAgICAgICAgICAgIDogcHJveHlEcmFmdC5vcmlnaW5hbDtcbiAgICAgICAgICAgIC8vIGZpbmFsIHVwZGF0ZSB2YWx1ZVxuICAgICAgICAgICAgc2V0KGlzU2V0ID8gc2V0TWFwIDogdGFyZ2V0LCBrZXksIHVwZGF0ZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVWYWx1ZSh2YWx1ZSwgaGFuZGxlZFNldCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc2V0TWFwKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHRhcmdldDtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuZnJvbShzZXQpO1xuICAgICAgICBzZXQuY2xlYXIoKTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzZXQuYWRkKHNldE1hcC5oYXModmFsdWUpID8gc2V0TWFwLmdldCh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmFsaXplQXNzaWduZWQocHJveHlEcmFmdCwga2V5KSB7XG4gICAgLy8gaGFuZGxlIHRoZSBkcmFmdGFibGUgYXNzaWduZWQgdmFsdWVz77yMIGFuZCB0aGUgdmFsdWUgaXMgbm90IGEgZHJhZnRcbiAgICBjb25zdCBjb3B5ID0gcHJveHlEcmFmdC50eXBlID09PSAzIC8qIERyYWZ0VHlwZS5TZXQgKi8gPyBwcm94eURyYWZ0LnNldE1hcCA6IHByb3h5RHJhZnQuY29weTtcbiAgICBpZiAocHJveHlEcmFmdC5maW5hbGl0aWVzLnJldm9rZS5sZW5ndGggPiAxICYmXG4gICAgICAgIHByb3h5RHJhZnQuYXNzaWduZWRNYXAuZ2V0KGtleSkgJiZcbiAgICAgICAgY29weSkge1xuICAgICAgICBoYW5kbGVWYWx1ZShnZXQoY29weSwga2V5KSwgcHJveHlEcmFmdC5maW5hbGl0aWVzLmhhbmRsZWRTZXQsIHByb3h5RHJhZnQub3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluYWxpemVTZXRWYWx1ZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LnR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLyAmJiB0YXJnZXQuY29weSkge1xuICAgICAgICB0YXJnZXQuY29weS5jbGVhcigpO1xuICAgICAgICB0YXJnZXQuc2V0TWFwLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQuY29weS5hZGQoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluYWxpemVQYXRjaGVzKHRhcmdldCwgZ2VuZXJhdGVQYXRjaGVzLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGNvbnN0IHNob3VsZEZpbmFsaXplID0gdGFyZ2V0Lm9wZXJhdGVkICYmXG4gICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcCAmJlxuICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuc2l6ZSA+IDAgJiZcbiAgICAgICAgIXRhcmdldC5maW5hbGl6ZWQ7XG4gICAgaWYgKHNob3VsZEZpbmFsaXplKSB7XG4gICAgICAgIGlmIChwYXRjaGVzICYmIGludmVyc2VQYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlUGF0aCA9IGdldFBhdGgodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChiYXNlUGF0aCkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlUGF0Y2hlcyh0YXJnZXQsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmZpbmFsaXplZCA9IHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFya0ZpbmFsaXphdGlvbih0YXJnZXQsIGtleSwgdmFsdWUsIGdlbmVyYXRlUGF0Y2hlcykge1xuICAgIGNvbnN0IHByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHZhbHVlKTtcbiAgICBpZiAocHJveHlEcmFmdCkge1xuICAgICAgICAvLyAhY2FzZTogYXNzaWduIHRoZSBkcmFmdCB2YWx1ZVxuICAgICAgICBpZiAoIXByb3h5RHJhZnQuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBwcm94eURyYWZ0LmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHByb3h5RHJhZnQuY2FsbGJhY2tzLnB1c2goKHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gdGFyZ2V0LnR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLyA/IHRhcmdldC5zZXRNYXAgOiB0YXJnZXQuY29weTtcbiAgICAgICAgICAgIGlmIChpc0VxdWFsKGdldChjb3B5LCBrZXkpLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZFZhbHVlID0gcHJveHlEcmFmdC5vcmlnaW5hbDtcbiAgICAgICAgICAgICAgICBpZiAocHJveHlEcmFmdC5jb3B5KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRWYWx1ZSA9IHByb3h5RHJhZnQuY29weTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxpemVTZXRWYWx1ZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGZpbmFsaXplUGF0Y2hlcyh0YXJnZXQsIGdlbmVyYXRlUGF0Y2hlcywgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQub3B0aW9ucy5lbmFibGVBdXRvRnJlZXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5vcHRpb25zLnVwZGF0ZWRWYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gdGFyZ2V0Lm9wdGlvbnMudXBkYXRlZFZhbHVlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm9wdGlvbnMudXBkYXRlZFZhbHVlcy5zZXQodXBkYXRlZFZhbHVlLCBwcm94eURyYWZ0Lm9yaWdpbmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZmluYWwgdXBkYXRlIHZhbHVlXG4gICAgICAgICAgICAgICAgc2V0KGNvcHksIGtleSwgdXBkYXRlZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0YXJnZXQub3B0aW9ucy5lbmFibGVBdXRvRnJlZXplKSB7XG4gICAgICAgICAgICAvLyAhY2FzZTogYXNzaWduIHRoZSBkcmFmdCB2YWx1ZSBpbiBjcm9zcyBkcmFmdCB0cmVlXG4gICAgICAgICAgICBpZiAocHJveHlEcmFmdC5maW5hbGl0aWVzICE9PSB0YXJnZXQuZmluYWxpdGllcykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5vcHRpb25zLmVuYWJsZUF1dG9GcmVlemUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEcmFmdGFibGUodmFsdWUsIHRhcmdldC5vcHRpb25zKSkge1xuICAgICAgICAvLyAhY2FzZTogYXNzaWduIHRoZSBub24tZHJhZnQgdmFsdWVcbiAgICAgICAgdGFyZ2V0LmZpbmFsaXRpZXMuZHJhZnQucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gdGFyZ2V0LnR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLyA/IHRhcmdldC5zZXRNYXAgOiB0YXJnZXQuY29weTtcbiAgICAgICAgICAgIGlmIChpc0VxdWFsKGdldChjb3B5LCBrZXkpLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZUFzc2lnbmVkKHRhcmdldCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhwcm94eVN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMsIHBhdGhBc0FycmF5KSB7XG4gICAgbGV0IHsgb3JpZ2luYWwsIGFzc2lnbmVkTWFwLCBvcHRpb25zIH0gPSBwcm94eVN0YXRlO1xuICAgIGxldCBjb3B5ID0gcHJveHlTdGF0ZS5jb3B5O1xuICAgIGlmIChjb3B5Lmxlbmd0aCA8IG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgICBbb3JpZ2luYWwsIGNvcHldID0gW2NvcHksIG9yaWdpbmFsXTtcbiAgICAgICAgW3BhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc107XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcmlnaW5hbC5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgaWYgKGFzc2lnbmVkTWFwLmdldChpbmRleC50b1N0cmluZygpKSAmJiBjb3B5W2luZGV4XSAhPT0gb3JpZ2luYWxbaW5kZXhdKSB7XG4gICAgICAgICAgICBjb25zdCBfcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaW5kZXhdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlc2NhcGVQYXRoKF9wYXRoLCBwYXRoQXNBcnJheSk7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBPcGVyYXRpb24uUmVwbGFjZSxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGEgZHJhZnQsIGl0IG5lZWRzIHRvIGJlIGRlZXAgY2xvbmVkLCBhbmQgaXQgbWF5IGFsc28gYmUgbm9uLWRyYWZ0LlxuICAgICAgICAgICAgICAgIHZhbHVlOiBjbG9uZUlmTmVlZGVkKGNvcHlbaW5kZXhdKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5SZXBsYWNlLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBkcmFmdCwgaXQgbmVlZHMgdG8gYmUgZGVlcCBjbG9uZWQsIGFuZCBpdCBtYXkgYWxzbyBiZSBub24tZHJhZnQuXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lSWZOZWVkZWQob3JpZ2luYWxbaW5kZXhdKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gb3JpZ2luYWwubGVuZ3RoOyBpbmRleCA8IGNvcHkubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgIGNvbnN0IF9wYXRoID0gYmFzZVBhdGguY29uY2F0KFtpbmRleF0pO1xuICAgICAgICBjb25zdCBwYXRoID0gZXNjYXBlUGF0aChfcGF0aCwgcGF0aEFzQXJyYXkpO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5BZGQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBkcmFmdCwgaXQgbmVlZHMgdG8gYmUgZGVlcCBjbG9uZWQsIGFuZCBpdCBtYXkgYWxzbyBiZSBub24tZHJhZnQuXG4gICAgICAgICAgICB2YWx1ZTogY2xvbmVJZk5lZWRlZChjb3B5W2luZGV4XSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3JpZ2luYWwubGVuZ3RoIDwgY29weS5sZW5ndGgpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY5MDIjYXBwZW5kaXgtQS40XG4gICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSwgaGVyZSB3ZSBvbmx5IGdlbmVyYXRlIGFuIG9wZXJhdGlvbiB0aGF0IHJlcGxhY2VzIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LFxuICAgICAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCBKU09OIFBhdGNoIHNwZWNpZmljYXRpb25cbiAgICAgICAgY29uc3QgeyBhcnJheUxlbmd0aEFzc2lnbm1lbnQgPSB0cnVlIH0gPSBvcHRpb25zLmVuYWJsZVBhdGNoZXM7XG4gICAgICAgIGlmIChhcnJheUxlbmd0aEFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gYmFzZVBhdGguY29uY2F0KFsnbGVuZ3RoJ10pO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVzY2FwZVBhdGgoX3BhdGgsIHBhdGhBc0FycmF5KTtcbiAgICAgICAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBPcGVyYXRpb24uUmVwbGFjZSxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbC5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gY29weS5sZW5ndGg7IG9yaWdpbmFsLmxlbmd0aCA8IGluZGV4OyBpbmRleCAtPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3BhdGggPSBiYXNlUGF0aC5jb25jYXQoW2luZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlc2NhcGVQYXRoKF9wYXRoLCBwYXRoQXNBcnJheSk7XG4gICAgICAgICAgICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBPcGVyYXRpb24uUmVtb3ZlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHsgb3JpZ2luYWwsIGNvcHksIGFzc2lnbmVkTWFwIH0sIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcywgcGF0aEFzQXJyYXkpIHtcbiAgICBhc3NpZ25lZE1hcC5mb3JFYWNoKChhc3NpZ25lZFZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IGdldChvcmlnaW5hbCwga2V5KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjbG9uZUlmTmVlZGVkKGdldChjb3B5LCBrZXkpKTtcbiAgICAgICAgY29uc3Qgb3AgPSAhYXNzaWduZWRWYWx1ZVxuICAgICAgICAgICAgPyBPcGVyYXRpb24uUmVtb3ZlXG4gICAgICAgICAgICA6IGhhcyhvcmlnaW5hbCwga2V5KVxuICAgICAgICAgICAgICAgID8gT3BlcmF0aW9uLlJlcGxhY2VcbiAgICAgICAgICAgICAgICA6IE9wZXJhdGlvbi5BZGQ7XG4gICAgICAgIGlmIChpc0VxdWFsKG9yaWdpbmFsVmFsdWUsIHZhbHVlKSAmJiBvcCA9PT0gT3BlcmF0aW9uLlJlcGxhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IF9wYXRoID0gYmFzZVBhdGguY29uY2F0KGtleSk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBlc2NhcGVQYXRoKF9wYXRoLCBwYXRoQXNBcnJheSk7XG4gICAgICAgIHBhdGNoZXMucHVzaChvcCA9PT0gT3BlcmF0aW9uLlJlbW92ZSA/IHsgb3AsIHBhdGggfSA6IHsgb3AsIHBhdGgsIHZhbHVlIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKG9wID09PSBPcGVyYXRpb24uQWRkXG4gICAgICAgICAgICA/IHsgb3A6IE9wZXJhdGlvbi5SZW1vdmUsIHBhdGggfVxuICAgICAgICAgICAgOiBvcCA9PT0gT3BlcmF0aW9uLlJlbW92ZVxuICAgICAgICAgICAgICAgID8geyBvcDogT3BlcmF0aW9uLkFkZCwgcGF0aCwgdmFsdWU6IG9yaWdpbmFsVmFsdWUgfVxuICAgICAgICAgICAgICAgIDogeyBvcDogT3BlcmF0aW9uLlJlcGxhY2UsIHBhdGgsIHZhbHVlOiBvcmlnaW5hbFZhbHVlIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTZXRQYXRjaGVzKHsgb3JpZ2luYWwsIGNvcHkgfSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzLCBwYXRoQXNBcnJheSkge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgb3JpZ2luYWwuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKCFjb3B5Lmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gYmFzZVBhdGguY29uY2F0KFtpbmRleF0pO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVzY2FwZVBhdGgoX3BhdGgsIHBhdGhBc0FycmF5KTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5SZW1vdmUsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgb3A6IE9wZXJhdGlvbi5BZGQsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgfSk7XG4gICAgaW5kZXggPSAwO1xuICAgIGNvcHkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKCFvcmlnaW5hbC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBfcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaW5kZXhdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlc2NhcGVQYXRoKF9wYXRoLCBwYXRoQXNBcnJheSk7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBPcGVyYXRpb24uQWRkLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgIG9wOiBPcGVyYXRpb24uUmVtb3ZlLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCArPSAxO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzKHByb3h5U3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGNvbnN0IHsgcGF0aEFzQXJyYXkgPSB0cnVlIH0gPSBwcm94eVN0YXRlLm9wdGlvbnMuZW5hYmxlUGF0Y2hlcztcbiAgICBzd2l0Y2ggKHByb3h5U3RhdGUudHlwZSkge1xuICAgICAgICBjYXNlIDAgLyogRHJhZnRUeXBlLk9iamVjdCAqLzpcbiAgICAgICAgY2FzZSAyIC8qIERyYWZ0VHlwZS5NYXAgKi86XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHByb3h5U3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcywgcGF0aEFzQXJyYXkpO1xuICAgICAgICBjYXNlIDEgLyogRHJhZnRUeXBlLkFycmF5ICovOlxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHByb3h5U3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcywgcGF0aEFzQXJyYXkpO1xuICAgICAgICBjYXNlIDMgLyogRHJhZnRUeXBlLlNldCAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVNldFBhdGNoZXMocHJveHlTdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzLCBwYXRoQXNBcnJheSk7XG4gICAgfVxufVxuXG5sZXQgcmVhZGFibGUgPSBmYWxzZTtcbmNvbnN0IGNoZWNrUmVhZGFibGUgPSAodmFsdWUsIG9wdGlvbnMsIGlnbm9yZUNoZWNrRHJhZnRhYmxlID0gZmFsc2UpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAoIWlzRHJhZnRhYmxlKHZhbHVlLCBvcHRpb25zKSB8fCBpZ25vcmVDaGVja0RyYWZ0YWJsZSkgJiZcbiAgICAgICAgIXJlYWRhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaWN0IG1vZGU6IE11dGFibGUgZGF0YSBjYW5ub3QgYmUgYWNjZXNzZWQgZGlyZWN0bHksIHBsZWFzZSB1c2UgJ3Vuc2FmZShjYWxsYmFjayknIHdyYXAuYCk7XG4gICAgfVxufTtcbi8qKlxuICogYHVuc2FmZShjYWxsYmFjaylgIHRvIGFjY2VzcyBtdXRhYmxlIGRhdGEgZGlyZWN0bHkgaW4gc3RyaWN0IG1vZGUuXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGUsIHVuc2FmZSB9IGZyb20gJy4uL2luZGV4JztcbiAqXG4gKiBjbGFzcyBGb29iYXIge1xuICogICBiYXIgPSAxO1xuICogfVxuICpcbiAqIGNvbnN0IGJhc2VTdGF0ZSA9IHsgZm9vYmFyOiBuZXcgRm9vYmFyKCkgfTtcbiAqIGNvbnN0IHN0YXRlID0gY3JlYXRlKFxuICogICBiYXNlU3RhdGUsXG4gKiAgIChkcmFmdCkgPT4ge1xuICogICAgdW5zYWZlKCgpID0+IHtcbiAqICAgICAgZHJhZnQuZm9vYmFyLmJhciA9IDI7XG4gKiAgICB9KTtcbiAqICAgfSxcbiAqICAge1xuICogICAgIHN0cmljdDogdHJ1ZSxcbiAqICAgfVxuICogKTtcbiAqXG4gKiBleHBlY3Qoc3RhdGUpLnRvQmUoYmFzZVN0YXRlKTtcbiAqIGV4cGVjdChzdGF0ZS5mb29iYXIpLnRvQmUoYmFzZVN0YXRlLmZvb2Jhcik7XG4gKiBleHBlY3Qoc3RhdGUuZm9vYmFyLmJhcikudG9CZSgyKTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1bnNhZmUoY2FsbGJhY2spIHtcbiAgICByZWFkYWJsZSA9IHRydWU7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgbWFwSGFuZGxlciA9IHtcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGxhdGVzdChnZXRQcm94eURyYWZ0KHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQuc2l6ZTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGxhdGVzdChnZXRQcm94eURyYWZ0KHRoaXMpKS5oYXMoa2V5KTtcbiAgICB9LFxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFByb3h5RHJhZnQodGhpcyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGxhdGVzdCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXNvdXJjZS5oYXMoa2V5KSB8fCAhaXNFcXVhbChzb3VyY2UuZ2V0KGtleSksIHZhbHVlKSkge1xuICAgICAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgICAgIG1hcmtDaGFuZ2VkKHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICB0YXJnZXQuY29weS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBtYXJrRmluYWxpemF0aW9uKHRhcmdldCwga2V5LCB2YWx1ZSwgZ2VuZXJhdGVQYXRjaGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgbWFya0NoYW5nZWQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHRhcmdldC5vcmlnaW5hbC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwLnNldChrZXksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuY29weS5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVuc3VyZVNoYWxsb3dDb3B5KHRhcmdldCk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHRhcmdldCk7XG4gICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiB0YXJnZXQub3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmNvcHkuY2xlYXIoKTtcbiAgICB9LFxuICAgIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgbGF0ZXN0KHRhcmdldCkuZm9yRWFjaCgoX3ZhbHVlLCBfa2V5KSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0KF9rZXkpLCBfa2V5LCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFByb3h5RHJhZnQodGhpcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0KHRhcmdldCkuZ2V0KGtleSk7XG4gICAgICAgIGNvbnN0IG11dGFibGUgPSAoKF9iID0gKF9hID0gdGFyZ2V0Lm9wdGlvbnMpLm1hcmspID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB2YWx1ZSwgZGF0YVR5cGVzKSkgPT09IGRhdGFUeXBlcy5tdXRhYmxlO1xuICAgICAgICBpZiAodGFyZ2V0Lm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICBjaGVja1JlYWRhYmxlKHZhbHVlLCB0YXJnZXQub3B0aW9ucywgbXV0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11dGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0LmZpbmFsaXplZCB8fCAhaXNEcmFmdGFibGUodmFsdWUsIHRhcmdldC5vcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRyYWZ0ZWQgb3IgcmVhc3NpZ25lZFxuICAgICAgICBpZiAodmFsdWUgIT09IHRhcmdldC5vcmlnaW5hbC5nZXQoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyYWZ0ID0gaW50ZXJuYWwuY3JlYXRlRHJhZnQoe1xuICAgICAgICAgICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgICAgICAgICAgcGFyZW50RHJhZnQ6IHRhcmdldCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGZpbmFsaXRpZXM6IHRhcmdldC5maW5hbGl0aWVzLFxuICAgICAgICAgICAgb3B0aW9uczogdGFyZ2V0Lm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICB0YXJnZXQuY29weS5zZXQoa2V5LCBkcmFmdCk7XG4gICAgICAgIHJldHVybiBkcmFmdDtcbiAgICB9LFxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBsYXRlc3QoZ2V0UHJveHlEcmFmdCh0aGlzKSkua2V5cygpO1xuICAgIH0sXG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2l0ZXJhdG9yU3ltYm9sXTogKCkgPT4gdGhpcy52YWx1ZXMoKSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBlbnRyaWVzKCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2l0ZXJhdG9yU3ltYm9sXTogKCkgPT4gdGhpcy5lbnRyaWVzKCksXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbcmVzdWx0LnZhbHVlLCB2YWx1ZV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBbaXRlcmF0b3JTeW1ib2xdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfSxcbn07XG5jb25zdCBtYXBIYW5kbGVyS2V5cyA9IFJlZmxlY3Qub3duS2V5cyhtYXBIYW5kbGVyKTtcblxuY29uc3QgZ2V0TmV4dEl0ZXJhdG9yID0gKHRhcmdldCwgaXRlcmF0b3IsIHsgaXNWYWx1ZXNJdGVyYXRvciB9KSA9PiAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGNvbnN0IGtleSA9IHJlc3VsdC52YWx1ZTtcbiAgICBsZXQgdmFsdWUgPSB0YXJnZXQuc2V0TWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGN1cnJlbnREcmFmdCA9IGdldFByb3h5RHJhZnQodmFsdWUpO1xuICAgIGNvbnN0IG11dGFibGUgPSAoKF9iID0gKF9hID0gdGFyZ2V0Lm9wdGlvbnMpLm1hcmspID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB2YWx1ZSwgZGF0YVR5cGVzKSkgPT09IGRhdGFUeXBlcy5tdXRhYmxlO1xuICAgIGlmICh0YXJnZXQub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgY2hlY2tSZWFkYWJsZShrZXksIHRhcmdldC5vcHRpb25zLCBtdXRhYmxlKTtcbiAgICB9XG4gICAgaWYgKCFtdXRhYmxlICYmXG4gICAgICAgICFjdXJyZW50RHJhZnQgJiZcbiAgICAgICAgaXNEcmFmdGFibGUoa2V5LCB0YXJnZXQub3B0aW9ucykgJiZcbiAgICAgICAgIXRhcmdldC5maW5hbGl6ZWQgJiZcbiAgICAgICAgdGFyZ2V0Lm9yaWdpbmFsLmhhcyhrZXkpKSB7XG4gICAgICAgIC8vIGRyYWZ0IGEgZHJhZnRhYmxlIG9yaWdpbmFsIHNldCBpdGVtXG4gICAgICAgIGNvbnN0IHByb3h5ID0gaW50ZXJuYWwuY3JlYXRlRHJhZnQoe1xuICAgICAgICAgICAgb3JpZ2luYWw6IGtleSxcbiAgICAgICAgICAgIHBhcmVudERyYWZ0OiB0YXJnZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBmaW5hbGl0aWVzOiB0YXJnZXQuZmluYWxpdGllcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IHRhcmdldC5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGFyZ2V0LnNldE1hcC5zZXQoa2V5LCBwcm94eSk7XG4gICAgICAgIHZhbHVlID0gcHJveHk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbnREcmFmdCkge1xuICAgICAgICAvLyBkcmFmdGVkXG4gICAgICAgIHZhbHVlID0gY3VycmVudERyYWZ0LnByb3h5O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGlzVmFsdWVzSXRlcmF0b3IgPyB2YWx1ZSA6IFt2YWx1ZSwgdmFsdWVdLFxuICAgIH07XG59O1xuY29uc3Qgc2V0SGFuZGxlciA9IHtcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5zZXRNYXAuc2l6ZTtcbiAgICB9LFxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICAvLyByZWFzc2lnbmVkIG9yIG5vbi1kcmFmdGFibGUgdmFsdWVzXG4gICAgICAgIGlmICh0YXJnZXQuc2V0TWFwLmhhcyh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgdmFsdWVQcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdCh2YWx1ZSk7XG4gICAgICAgIC8vIGRyYWZ0ZWRcbiAgICAgICAgaWYgKHZhbHVlUHJveHlEcmFmdCAmJiB0YXJnZXQuc2V0TWFwLmhhcyh2YWx1ZVByb3h5RHJhZnQub3JpZ2luYWwpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgICAgIG1hcmtDaGFuZ2VkKHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuc2V0KHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIHRhcmdldC5zZXRNYXAuc2V0KHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBtYXJrRmluYWxpemF0aW9uKHRhcmdldCwgdmFsdWUsIHZhbHVlLCBnZW5lcmF0ZVBhdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVsZXRlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgbWFya0NoYW5nZWQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgdmFsdWVQcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZVByb3h5RHJhZnQgJiYgdGFyZ2V0LnNldE1hcC5oYXModmFsdWVQcm94eURyYWZ0Lm9yaWdpbmFsKSkge1xuICAgICAgICAgICAgLy8gZGVsZXRlIGRyYWZ0ZWRcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5zZXQodmFsdWVQcm94eURyYWZ0Lm9yaWdpbmFsLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnNldE1hcC5kZWxldGUodmFsdWVQcm94eURyYWZ0Lm9yaWdpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlUHJveHlEcmFmdCAmJiB0YXJnZXQuc2V0TWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIG5vbi1kcmFmdGFibGUgdmFsdWVzXG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuc2V0KHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZWFzc2lnbmVkXG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWxldGUgcmVhc3NpZ25lZCBvciBub24tZHJhZnRhYmxlIHZhbHVlc1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnNldE1hcC5kZWxldGUodmFsdWUpO1xuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHRoaXMpO1xuICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICBtYXJrQ2hhbmdlZCh0YXJnZXQpO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRhcmdldC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwLnNldCh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zZXRNYXAuY2xlYXIoKTtcbiAgICB9LFxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UHJveHlEcmFmdCh0aGlzKTtcbiAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0YXJnZXQuc2V0TWFwLmtleXMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLnZhbHVlcygpLFxuICAgICAgICAgICAgbmV4dDogZ2V0TmV4dEl0ZXJhdG9yKHRhcmdldCwgaXRlcmF0b3IsIHsgaXNWYWx1ZXNJdGVyYXRvcjogdHJ1ZSB9KSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFByb3h5RHJhZnQodGhpcyk7XG4gICAgICAgIGVuc3VyZVNoYWxsb3dDb3B5KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGFyZ2V0LnNldE1hcC5rZXlzKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy5lbnRyaWVzKCksXG4gICAgICAgICAgICBuZXh0OiBnZXROZXh0SXRlcmF0b3IodGFyZ2V0LCBpdGVyYXRvciwge1xuICAgICAgICAgICAgICAgIGlzVmFsdWVzSXRlcmF0b3I6IGZhbHNlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9LFxuICAgIFtpdGVyYXRvclN5bWJvbF0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH0sXG4gICAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5pZiAoU2V0LnByb3RvdHlwZS5kaWZmZXJlbmNlKSB7XG4gICAgLy8gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBuZXcgU2V0IG1ldGhvZHNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zZXQtbWV0aG9kc1xuICAgIC8vIEFuZCBgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc2V0LW1ldGhvZHMvYmxvYi9tYWluL2RldGFpbHMubWQjc3ltYm9sc3BlY2llc2AgaGFzIHNvbWUgZGV0YWlscyBhYm91dCB0aGUgYEBAc3BlY2llc2Agc3ltYm9sLlxuICAgIC8vIFNvIHdlIGNhbid0IHVzZSBTdWJTZXQgaW5zdGFuY2UgY29uc3RydWN0b3IgdG8gZ2V0IHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgU3ViU2V0IGluc3RhbmNlLlxuICAgIE9iamVjdC5hc3NpZ24oc2V0SGFuZGxlciwge1xuICAgICAgICBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTZXQucHJvdG90eXBlLmludGVyc2VjdGlvbi5jYWxsKG5ldyBTZXQodGhpcy52YWx1ZXMoKSksIG90aGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5pb24ob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTZXQucHJvdG90eXBlLnVuaW9uLmNhbGwobmV3IFNldCh0aGlzLnZhbHVlcygpKSwgb3RoZXIpO1xuICAgICAgICB9LFxuICAgICAgICBkaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gU2V0LnByb3RvdHlwZS5kaWZmZXJlbmNlLmNhbGwobmV3IFNldCh0aGlzLnZhbHVlcygpKSwgb3RoZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzeW1tZXRyaWNEaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gU2V0LnByb3RvdHlwZS5zeW1tZXRyaWNEaWZmZXJlbmNlLmNhbGwobmV3IFNldCh0aGlzLnZhbHVlcygpKSwgb3RoZXIpO1xuICAgICAgICB9LFxuICAgICAgICBpc1N1YnNldE9mKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gU2V0LnByb3RvdHlwZS5pc1N1YnNldE9mLmNhbGwobmV3IFNldCh0aGlzLnZhbHVlcygpKSwgb3RoZXIpO1xuICAgICAgICB9LFxuICAgICAgICBpc1N1cGVyc2V0T2Yob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTZXQucHJvdG90eXBlLmlzU3VwZXJzZXRPZi5jYWxsKG5ldyBTZXQodGhpcy52YWx1ZXMoKSksIG90aGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEaXNqb2ludEZyb20ob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTZXQucHJvdG90eXBlLmlzRGlzam9pbnRGcm9tLmNhbGwobmV3IFNldCh0aGlzLnZhbHVlcygpKSwgb3RoZXIpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuY29uc3Qgc2V0SGFuZGxlcktleXMgPSBSZWZsZWN0Lm93bktleXMoc2V0SGFuZGxlcik7XG5cbmNvbnN0IGRyYWZ0c0NhY2hlID0gbmV3IFdlYWtTZXQoKTtcbmNvbnN0IHByb3h5SGFuZGxlciA9IHtcbiAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNvcHkgPSAoX2EgPSB0YXJnZXQuY29weSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tleV07XG4gICAgICAgIC8vIEltcHJvdmUgZHJhZnQgcmVhZGluZyBwZXJmb3JtYW5jZSBieSBjYWNoaW5nIHRoZSBkcmFmdCBjb3B5LlxuICAgICAgICBpZiAoY29weSAmJiBkcmFmdHNDYWNoZS5oYXMoY29weSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFBST1hZX0RSQUZUKVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgbGV0IG1hcmtSZXN1bHQ7XG4gICAgICAgIGlmICh0YXJnZXQub3B0aW9ucy5tYXJrKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgYFVuY2F1Z2h0IFR5cGVFcnJvcjogTWV0aG9kIGdldCBNYXAucHJvdG90eXBlLnNpemUgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlciAjPE1hcD5gXG4gICAgICAgICAgICAvLyBvciBgVW5jYXVnaHQgVHlwZUVycm9yOiBNZXRob2QgZ2V0IFNldC5wcm90b3R5cGUuc2l6ZSBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyICM8U2V0PmBcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ga2V5ID09PSAnc2l6ZScgJiZcbiAgICAgICAgICAgICAgICAodGFyZ2V0Lm9yaWdpbmFsIGluc3RhbmNlb2YgTWFwIHx8IHRhcmdldC5vcmlnaW5hbCBpbnN0YW5jZW9mIFNldClcbiAgICAgICAgICAgICAgICA/IFJlZmxlY3QuZ2V0KHRhcmdldC5vcmlnaW5hbCwga2V5KVxuICAgICAgICAgICAgICAgIDogUmVmbGVjdC5nZXQodGFyZ2V0Lm9yaWdpbmFsLCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIG1hcmtSZXN1bHQgPSB0YXJnZXQub3B0aW9ucy5tYXJrKHZhbHVlLCBkYXRhVHlwZXMpO1xuICAgICAgICAgICAgaWYgKG1hcmtSZXN1bHQgPT09IGRhdGFUeXBlcy5tdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1JlYWRhYmxlKHZhbHVlLCB0YXJnZXQub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2UgPSBsYXRlc3QodGFyZ2V0KTtcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIE1hcCAmJiBtYXBIYW5kbGVyS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc2l6ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtYXBIYW5kbGVyLCAnc2l6ZScpLmdldC5jYWxsKHRhcmdldC5wcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBtYXBIYW5kbGVyW2tleV07XG4gICAgICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5iaW5kKHRhcmdldC5wcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFNldCAmJiBzZXRIYW5kbGVyS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc2l6ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzZXRIYW5kbGVyLCAnc2l6ZScpLmdldC5jYWxsKHRhcmdldC5wcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRIYW5kbGVyW2tleV07XG4gICAgICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5iaW5kKHRhcmdldC5wcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXMoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZGVzY1xuICAgICAgICAgICAgICAgID8gYHZhbHVlYCBpbiBkZXNjXG4gICAgICAgICAgICAgICAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IC8vICFjYXNlOiBzdXBwb3J0IGZvciBnZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGRlc2MuZ2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0YXJnZXQucHJveHkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgY2hlY2tSZWFkYWJsZSh2YWx1ZSwgdGFyZ2V0Lm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQuZmluYWxpemVkIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSwgdGFyZ2V0Lm9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGFzc2lnbmVkIHZhbHVlcyBhcmUgbm90IGRyYWZ0ZWRcbiAgICAgICAgaWYgKHZhbHVlID09PSBwZWVrKHRhcmdldC5vcmlnaW5hbCwga2V5KSkge1xuICAgICAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldC5jb3B5W2tleV0gPSBjcmVhdGVEcmFmdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IHRhcmdldC5vcmlnaW5hbFtrZXldLFxuICAgICAgICAgICAgICAgIHBhcmVudERyYWZ0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAga2V5OiB0YXJnZXQudHlwZSA9PT0gMSAvKiBEcmFmdFR5cGUuQXJyYXkgKi8gPyBOdW1iZXIoa2V5KSA6IGtleSxcbiAgICAgICAgICAgICAgICBmaW5hbGl0aWVzOiB0YXJnZXQuZmluYWxpdGllcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB0YXJnZXQub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gIWNhc2U6IHN1cHBvcnQgZm9yIGN1c3RvbSBzaGFsbG93IGNvcHkgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFya1Jlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHRhcmdldC5jb3B5W2tleV0pO1xuICAgICAgICAgICAgICAgIGVuc3VyZVNoYWxsb3dDb3B5KHN1YlByb3h5RHJhZnQpO1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYSBjdXN0b20gc2hhbGxvdyBjb3B5IHRvIHVwZGF0ZSB0byBhIG5ldyBjb3B5XG4gICAgICAgICAgICAgICAgbWFya0NoYW5nZWQoc3ViUHJveHlEcmFmdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YlByb3h5RHJhZnQuY29weTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuY29weVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGFyZ2V0LnR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLyB8fCB0YXJnZXQudHlwZSA9PT0gMiAvKiBEcmFmdFR5cGUuTWFwICovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcC9TZXQgZHJhZnQgZG9lcyBub3Qgc3VwcG9ydCBhbnkgcHJvcGVydHkgYXNzaWdubWVudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgX2tleTtcbiAgICAgICAgaWYgKHRhcmdldC50eXBlID09PSAxIC8qIERyYWZ0VHlwZS5BcnJheSAqLyAmJlxuICAgICAgICAgICAga2V5ICE9PSAnbGVuZ3RoJyAmJlxuICAgICAgICAgICAgIShOdW1iZXIuaXNJbnRlZ2VyKChfa2V5ID0gTnVtYmVyKGtleSkpKSAmJlxuICAgICAgICAgICAgICAgIF9rZXkgPj0gMCAmJlxuICAgICAgICAgICAgICAgIChrZXkgPT09IDAgfHwgX2tleSA9PT0gMCB8fCBTdHJpbmcoX2tleSkgPT09IFN0cmluZyhrZXkpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBzdXBwb3J0cyBzZXR0aW5nIGFycmF5IGluZGljZXMgYW5kIHRoZSAnbGVuZ3RoJyBwcm9wZXJ0eS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvcihsYXRlc3QodGFyZ2V0KSwga2V5KTtcbiAgICAgICAgaWYgKGRlc2MgPT09IG51bGwgfHwgZGVzYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVzYy5zZXQpIHtcbiAgICAgICAgICAgIC8vICFjYXNlOiBjb3ZlciB0aGUgY2FzZSBvZiBzZXR0ZXJcbiAgICAgICAgICAgIGRlc2Muc2V0LmNhbGwodGFyZ2V0LnByb3h5LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGVlayhsYXRlc3QodGFyZ2V0KSwga2V5KTtcbiAgICAgICAgY29uc3QgY3VycmVudFByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KGN1cnJlbnQpO1xuICAgICAgICBpZiAoY3VycmVudFByb3h5RHJhZnQgJiYgaXNFcXVhbChjdXJyZW50UHJveHlEcmFmdC5vcmlnaW5hbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAvLyAhY2FzZTogaWdub3JlIHRoZSBjYXNlIG9mIGFzc2lnbmluZyB0aGUgb3JpZ2luYWwgZHJhZnRhYmxlIHZhbHVlIHRvIGEgZHJhZnRcbiAgICAgICAgICAgIHRhcmdldC5jb3B5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcCA9IChfYSA9IHRhcmdldC5hc3NpZ25lZE1hcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwLnNldChrZXksIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vICFjYXNlOiBoYW5kbGUgbmV3IHByb3BzIHdpdGggdmFsdWUgJ3VuZGVmaW5lZCdcbiAgICAgICAgaWYgKGlzRXF1YWwodmFsdWUsIGN1cnJlbnQpICYmXG4gICAgICAgICAgICAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBoYXModGFyZ2V0Lm9yaWdpbmFsLCBrZXkpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBlbnN1cmVTaGFsbG93Q29weSh0YXJnZXQpO1xuICAgICAgICBtYXJrQ2hhbmdlZCh0YXJnZXQpO1xuICAgICAgICBpZiAoaGFzKHRhcmdldC5vcmlnaW5hbCwga2V5KSAmJiBpc0VxdWFsKHZhbHVlLCB0YXJnZXQub3JpZ2luYWxba2V5XSkpIHtcbiAgICAgICAgICAgIC8vICFjYXNlOiBoYW5kbGUgdGhlIGNhc2Ugb2YgYXNzaWduaW5nIHRoZSBvcmlnaW5hbCBub24tZHJhZnRhYmxlIHZhbHVlIHRvIGEgZHJhZnRcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hc3NpZ25lZE1hcC5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuY29weVtrZXldID0gdmFsdWU7XG4gICAgICAgIG1hcmtGaW5hbGl6YXRpb24odGFyZ2V0LCBrZXksIHZhbHVlLCBnZW5lcmF0ZVBhdGNoZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIGxhdGVzdCh0YXJnZXQpO1xuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3QodGFyZ2V0KSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbGF0ZXN0KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICAgIGlmICghZGVzY3JpcHRvcilcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRhcmdldC50eXBlICE9PSAxIC8qIERyYWZ0VHlwZS5BcnJheSAqLyB8fCBrZXkgIT09ICdsZW5ndGgnLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgdmFsdWU6IHNvdXJjZVtrZXldLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldC5vcmlnaW5hbCk7XG4gICAgfSxcbiAgICBzZXRQcm90b3R5cGVPZigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY2FsbCAnc2V0UHJvdG90eXBlT2YoKScgb24gZHJhZnRzYCk7XG4gICAgfSxcbiAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY2FsbCAnZGVmaW5lUHJvcGVydHkoKScgb24gZHJhZnRzYCk7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0YXJnZXQudHlwZSA9PT0gMSAvKiBEcmFmdFR5cGUuQXJyYXkgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm94eUhhbmRsZXIuc2V0LmNhbGwodGhpcywgdGFyZ2V0LCBrZXksIHVuZGVmaW5lZCwgdGFyZ2V0LnByb3h5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVlayh0YXJnZXQub3JpZ2luYWwsIGtleSkgIT09IHVuZGVmaW5lZCB8fCBrZXkgaW4gdGFyZ2V0Lm9yaWdpbmFsKSB7XG4gICAgICAgICAgICAvLyAhY2FzZTogZGVsZXRlIGFuIGV4aXN0aW5nIGtleVxuICAgICAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkodGFyZ2V0KTtcbiAgICAgICAgICAgIG1hcmtDaGFuZ2VkKHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFzc2lnbmVkTWFwID0gKF9hID0gdGFyZ2V0LmFzc2lnbmVkTWFwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgbm9uLWV4aXN0ZW50IGtleSBoYXMgYmVlbiBkZWxldGVkXG4gICAgICAgICAgICB0YXJnZXQuYXNzaWduZWRNYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5jb3B5KVxuICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5jb3B5W2tleV07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlRHJhZnQoY3JlYXRlRHJhZnRPcHRpb25zKSB7XG4gICAgY29uc3QgeyBvcmlnaW5hbCwgcGFyZW50RHJhZnQsIGtleSwgZmluYWxpdGllcywgb3B0aW9ucyB9ID0gY3JlYXRlRHJhZnRPcHRpb25zO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKG9yaWdpbmFsKTtcbiAgICBjb25zdCBwcm94eURyYWZ0ID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBmaW5hbGl6ZWQ6IGZhbHNlLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudERyYWZ0LFxuICAgICAgICBvcmlnaW5hbCxcbiAgICAgICAgY29weTogbnVsbCxcbiAgICAgICAgcHJveHk6IG51bGwsXG4gICAgICAgIGZpbmFsaXRpZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC8vIE1hcHBpbmcgb2YgZHJhZnQgU2V0IGl0ZW1zIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgZHJhZnQgdmFsdWVzLlxuICAgICAgICBzZXRNYXA6IHR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqL1xuICAgICAgICAgICAgPyBuZXcgTWFwKG9yaWdpbmFsLmVudHJpZXMoKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgLy8gIWNhc2U6IHVuZGVmaW5lZCBhcyBhIGRyYWZ0IG1hcCBrZXlcbiAgICBpZiAoa2V5IHx8ICdrZXknIGluIGNyZWF0ZURyYWZ0T3B0aW9ucykge1xuICAgICAgICBwcm94eURyYWZ0LmtleSA9IGtleTtcbiAgICB9XG4gICAgY29uc3QgeyBwcm94eSwgcmV2b2tlIH0gPSBQcm94eS5yZXZvY2FibGUodHlwZSA9PT0gMSAvKiBEcmFmdFR5cGUuQXJyYXkgKi8gPyBPYmplY3QuYXNzaWduKFtdLCBwcm94eURyYWZ0KSA6IHByb3h5RHJhZnQsIHByb3h5SGFuZGxlcik7XG4gICAgZmluYWxpdGllcy5yZXZva2UucHVzaChyZXZva2UpO1xuICAgIGRyYWZ0c0NhY2hlLmFkZChwcm94eSk7XG4gICAgcHJveHlEcmFmdC5wcm94eSA9IHByb3h5O1xuICAgIGlmIChwYXJlbnREcmFmdCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBwYXJlbnREcmFmdDtcbiAgICAgICAgdGFyZ2V0LmZpbmFsaXRpZXMuZHJhZnQucHVzaCgocGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBvbGRQcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdChwcm94eSk7XG4gICAgICAgICAgICAvLyBpZiB0YXJnZXQgaXMgYSBTZXQgZHJhZnQsIGBzZXRNYXBgIGlzIHRoZSByZWFsIFNldCBjb3BpZXMgcHJveHkgbWFwcGluZy5cbiAgICAgICAgICAgIGxldCBjb3B5ID0gdGFyZ2V0LnR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqLyA/IHRhcmdldC5zZXRNYXAgOiB0YXJnZXQuY29weTtcbiAgICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gZ2V0KGNvcHksIGtleSk7XG4gICAgICAgICAgICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdChkcmFmdCk7XG4gICAgICAgICAgICBpZiAocHJveHlEcmFmdCkge1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgdXBkYXRlZCB2YWx1ZSB0byB0aGUgY29weSBvYmplY3RcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZFZhbHVlID0gcHJveHlEcmFmdC5vcmlnaW5hbDtcbiAgICAgICAgICAgICAgICBpZiAocHJveHlEcmFmdC5vcGVyYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkVmFsdWUgPSBnZXRWYWx1ZShkcmFmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsaXplU2V0VmFsdWUocHJveHlEcmFmdCk7XG4gICAgICAgICAgICAgICAgZmluYWxpemVQYXRjaGVzKHByb3h5RHJhZnQsIGdlbmVyYXRlUGF0Y2hlcywgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQub3B0aW9ucy5lbmFibGVBdXRvRnJlZXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5vcHRpb25zLnVwZGF0ZWRWYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gdGFyZ2V0Lm9wdGlvbnMudXBkYXRlZFZhbHVlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm9wdGlvbnMudXBkYXRlZFZhbHVlcy5zZXQodXBkYXRlZFZhbHVlLCBwcm94eURyYWZ0Lm9yaWdpbmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZmluYWwgdXBkYXRlIHZhbHVlXG4gICAgICAgICAgICAgICAgc2V0KGNvcHksIGtleSwgdXBkYXRlZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICFjYXNlOiBoYW5kbGUgdGhlIGRlbGV0ZWQga2V5XG4gICAgICAgICAgICAoX2IgPSBvbGRQcm94eURyYWZ0LmNhbGxiYWNrcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gIWNhc2U6IGhhbmRsZSB0aGUgcm9vdCBkcmFmdFxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRQcm94eURyYWZ0KHByb3h5KTtcbiAgICAgICAgdGFyZ2V0LmZpbmFsaXRpZXMuZHJhZnQucHVzaCgocGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpID0+IHtcbiAgICAgICAgICAgIGZpbmFsaXplU2V0VmFsdWUodGFyZ2V0KTtcbiAgICAgICAgICAgIGZpbmFsaXplUGF0Y2hlcyh0YXJnZXQsIGdlbmVyYXRlUGF0Y2hlcywgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5O1xufVxuaW50ZXJuYWwuY3JlYXRlRHJhZnQgPSBjcmVhdGVEcmFmdDtcbmZ1bmN0aW9uIGZpbmFsaXplRHJhZnQocmVzdWx0LCByZXR1cm5lZFZhbHVlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcywgZW5hYmxlQXV0b0ZyZWV6ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdChyZXN1bHQpO1xuICAgIGNvbnN0IG9yaWdpbmFsID0gKF9hID0gcHJveHlEcmFmdCA9PT0gbnVsbCB8fCBwcm94eURyYWZ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm94eURyYWZ0Lm9yaWdpbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZXN1bHQ7XG4gICAgY29uc3QgaGFzUmV0dXJuZWRWYWx1ZSA9ICEhcmV0dXJuZWRWYWx1ZS5sZW5ndGg7XG4gICAgaWYgKHByb3h5RHJhZnQgPT09IG51bGwgfHwgcHJveHlEcmFmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJveHlEcmFmdC5vcGVyYXRlZCkge1xuICAgICAgICB3aGlsZSAocHJveHlEcmFmdC5maW5hbGl0aWVzLmRyYWZ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsaXplID0gcHJveHlEcmFmdC5maW5hbGl0aWVzLmRyYWZ0LnBvcCgpO1xuICAgICAgICAgICAgZmluYWxpemUocGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gaGFzUmV0dXJuZWRWYWx1ZVxuICAgICAgICA/IHJldHVybmVkVmFsdWVbMF1cbiAgICAgICAgOiBwcm94eURyYWZ0XG4gICAgICAgICAgICA/IHByb3h5RHJhZnQub3BlcmF0ZWRcbiAgICAgICAgICAgICAgICA/IHByb3h5RHJhZnQuY29weVxuICAgICAgICAgICAgICAgIDogcHJveHlEcmFmdC5vcmlnaW5hbFxuICAgICAgICAgICAgOiByZXN1bHQ7XG4gICAgaWYgKHByb3h5RHJhZnQpXG4gICAgICAgIHJldm9rZVByb3h5KHByb3h5RHJhZnQpO1xuICAgIGlmIChlbmFibGVBdXRvRnJlZXplKSB7XG4gICAgICAgIGRlZXBGcmVlemUoc3RhdGUsIHN0YXRlLCBwcm94eURyYWZ0ID09PSBudWxsIHx8IHByb3h5RHJhZnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3h5RHJhZnQub3B0aW9ucy51cGRhdGVkVmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHBhdGNoZXMgJiYgaGFzUmV0dXJuZWRWYWx1ZVxuICAgICAgICAgICAgPyBbeyBvcDogT3BlcmF0aW9uLlJlcGxhY2UsIHBhdGg6IFtdLCB2YWx1ZTogcmV0dXJuZWRWYWx1ZVswXSB9XVxuICAgICAgICAgICAgOiBwYXRjaGVzLFxuICAgICAgICBpbnZlcnNlUGF0Y2hlcyAmJiBoYXNSZXR1cm5lZFZhbHVlXG4gICAgICAgICAgICA/IFt7IG9wOiBPcGVyYXRpb24uUmVwbGFjZSwgcGF0aDogW10sIHZhbHVlOiBvcmlnaW5hbCB9XVxuICAgICAgICAgICAgOiBpbnZlcnNlUGF0Y2hlcyxcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBkcmFmdGlmeShiYXNlU3RhdGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZmluYWxpdGllcyA9IHtcbiAgICAgICAgZHJhZnQ6IFtdLFxuICAgICAgICByZXZva2U6IFtdLFxuICAgICAgICBoYW5kbGVkU2V0OiBuZXcgV2Vha1NldCgpLFxuICAgIH07XG4gICAgbGV0IHBhdGNoZXM7XG4gICAgbGV0IGludmVyc2VQYXRjaGVzO1xuICAgIGlmIChvcHRpb25zLmVuYWJsZVBhdGNoZXMpIHtcbiAgICAgICAgcGF0Y2hlcyA9IFtdO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBpc011dGFibGUgPSAoKF9hID0gb3B0aW9ucy5tYXJrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBiYXNlU3RhdGUsIGRhdGFUeXBlcykpID09PSBkYXRhVHlwZXMubXV0YWJsZSB8fFxuICAgICAgICAhaXNEcmFmdGFibGUoYmFzZVN0YXRlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkcmFmdCA9IGlzTXV0YWJsZVxuICAgICAgICA/IGJhc2VTdGF0ZVxuICAgICAgICA6IGNyZWF0ZURyYWZ0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsOiBiYXNlU3RhdGUsXG4gICAgICAgICAgICBwYXJlbnREcmFmdDogbnVsbCxcbiAgICAgICAgICAgIGZpbmFsaXRpZXMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBkcmFmdCxcbiAgICAgICAgKHJldHVybmVkVmFsdWUgPSBbXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2ZpbmFsaXplZFN0YXRlLCBmaW5hbGl6ZWRQYXRjaGVzLCBmaW5hbGl6ZWRJbnZlcnNlUGF0Y2hlc10gPSBmaW5hbGl6ZURyYWZ0KGRyYWZ0LCByZXR1cm5lZFZhbHVlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcywgb3B0aW9ucy5lbmFibGVBdXRvRnJlZXplKTtcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9ucy5lbmFibGVQYXRjaGVzXG4gICAgICAgICAgICAgICAgPyBbZmluYWxpemVkU3RhdGUsIGZpbmFsaXplZFBhdGNoZXMsIGZpbmFsaXplZEludmVyc2VQYXRjaGVzXVxuICAgICAgICAgICAgICAgIDogZmluYWxpemVkU3RhdGUpO1xuICAgICAgICB9LFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJldHVyblZhbHVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb3REcmFmdCwgdmFsdWUsIHVzZVJhd1JldHVybiA9IGZhbHNlLCBpc1Jvb3QgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGZvckVhY2godmFsdWUsIChrZXksIGl0ZW0sIHNvdXJjZSkgPT4ge1xuICAgICAgICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdChpdGVtKTtcbiAgICAgICAgLy8ganVzdCBoYW5kbGUgdGhlIGRyYWZ0IHdoaWNoIGlzIGNyZWF0ZWQgYnkgdGhlIHNhbWUgcm9vdERyYWZ0XG4gICAgICAgIGlmIChwcm94eURyYWZ0ICYmXG4gICAgICAgICAgICByb290RHJhZnQgJiZcbiAgICAgICAgICAgIHByb3h5RHJhZnQuZmluYWxpdGllcyA9PT0gcm9vdERyYWZ0LmZpbmFsaXRpZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaXNDb250YWluRHJhZnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gcHJveHlEcmFmdC5vcmlnaW5hbDtcbiAgICAgICAgICAgIC8vIGZpbmFsIHVwZGF0ZSB2YWx1ZSwgYnV0IGp1c3QgaGFuZGxlIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IEFycmF5LmZyb20oc291cmNlKTtcbiAgICAgICAgICAgICAgICBzb3VyY2UuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBhcnIuZm9yRWFjaCgoX2l0ZW0pID0+IHNvdXJjZS5hZGQoa2V5ID09PSBfaXRlbSA/IGN1cnJlbnRWYWx1ZSA6IF9pdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXQoc291cmNlLCBrZXksIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBpdGVtO1xuICAgICAgICAgICAgb3B0aW9ucy5pc1Jvb3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGhhbmRsZVJldHVyblZhbHVlKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMuaXNDb250YWluRHJhZnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSByZXR1cm4gdmFsdWUgZG9lcyBub3QgY29udGFpbiBhbnkgZHJhZnQsIHBsZWFzZSB1c2UgJ3Jhd1JldHVybigpJyB0byB3cmFwIHRoZSByZXR1cm4gdmFsdWUgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5gKTtcbiAgICAgICAgaWYgKHVzZVJhd1JldHVybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgcmV0dXJuIHZhbHVlIGNvbnRhaW5zIGRyYWZ0cywgcGxlYXNlIGRvbid0IHVzZSAncmF3UmV0dXJuKCknIHRvIHdyYXAgdGhlIHJldHVybiB2YWx1ZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnQodGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHRhcmdldCk7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZSh0YXJnZXQsIHByb3h5RHJhZnQgPT09IG51bGwgfHwgcHJveHlEcmFmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJveHlEcmFmdC5vcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZSh0YXJnZXQpO1xuICAgIGlmIChwcm94eURyYWZ0ICYmICFwcm94eURyYWZ0Lm9wZXJhdGVkKVxuICAgICAgICByZXR1cm4gcHJveHlEcmFmdC5vcmlnaW5hbDtcbiAgICBsZXQgY3VycmVudFZhbHVlO1xuICAgIGZ1bmN0aW9uIGVuc3VyZVNoYWxsb3dDb3B5KCkge1xuICAgICAgICBjdXJyZW50VmFsdWUgPVxuICAgICAgICAgICAgdHlwZSA9PT0gMiAvKiBEcmFmdFR5cGUuTWFwICovXG4gICAgICAgICAgICAgICAgPyAhaXNCYXNlTWFwSW5zdGFuY2UodGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkuY29uc3RydWN0b3IpKHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgTWFwKHRhcmdldClcbiAgICAgICAgICAgICAgICA6IHR5cGUgPT09IDMgLyogRHJhZnRUeXBlLlNldCAqL1xuICAgICAgICAgICAgICAgICAgICA/IEFycmF5LmZyb20ocHJveHlEcmFmdC5zZXRNYXAudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgICAgIDogc2hhbGxvd0NvcHkodGFyZ2V0LCBwcm94eURyYWZ0ID09PSBudWxsIHx8IHByb3h5RHJhZnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3h5RHJhZnQub3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChwcm94eURyYWZ0KSB7XG4gICAgICAgIC8vIEl0J3MgYSBwcm94eSBkcmFmdCwgbGV0J3MgY3JlYXRlIGEgc2hhbGxvdyBjb3B5IGVhZ2VybHlcbiAgICAgICAgcHJveHlEcmFmdC5maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZW5zdXJlU2hhbGxvd0NvcHkoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHByb3h5RHJhZnQuZmluYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0J3Mgbm90IGEgcHJveHkgZHJhZnQsIGxldCdzIHVzZSB0aGUgdGFyZ2V0IGRpcmVjdGx5IGFuZCBsZXQncyBzZWVcbiAgICAgICAgLy8gbGF6aWx5IGlmIHdlIG5lZWQgdG8gY3JlYXRlIGEgc2hhbGxvdyBjb3B5XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHRhcmdldDtcbiAgICB9XG4gICAgZm9yRWFjaChjdXJyZW50VmFsdWUsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChwcm94eURyYWZ0ICYmIGlzRXF1YWwoZ2V0KHByb3h5RHJhZnQub3JpZ2luYWwsIGtleSksIHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBnZXRDdXJyZW50KHZhbHVlKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIGVuc3VyZVNoYWxsb3dDb3B5KCk7XG4gICAgICAgICAgICBzZXQoY3VycmVudFZhbHVlLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlID09PSAzIC8qIERyYWZ0VHlwZS5TZXQgKi8pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoX2EgPSBwcm94eURyYWZ0ID09PSBudWxsIHx8IHByb3h5RHJhZnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3h5RHJhZnQub3JpZ2luYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgcmV0dXJuICFpc0Jhc2VTZXRJbnN0YW5jZSh2YWx1ZSlcbiAgICAgICAgICAgID8gbmV3IChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpLmNvbnN0cnVjdG9yKShjdXJyZW50VmFsdWUpXG4gICAgICAgICAgICA6IG5ldyBTZXQoY3VycmVudFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGN1cnJlbnQodGFyZ2V0KSB7XG4gICAgaWYgKCFpc0RyYWZ0KHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjdXJyZW50KCkgaXMgb25seSB1c2VkIGZvciBEcmFmdCwgcGFyYW1ldGVyOiAke3RhcmdldH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEN1cnJlbnQodGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBgbWFrZUNyZWF0b3Iob3B0aW9ucylgIHRvIG1ha2UgYSBjcmVhdG9yIGZ1bmN0aW9uLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWFrZUNyZWF0b3IgfSBmcm9tICcuLi9pbmRleCc7XG4gKlxuICogY29uc3QgYmFzZVN0YXRlID0geyBmb286IHsgYmFyOiAnc3RyJyB9LCBhcnI6IFtdIH07XG4gKiBjb25zdCBjcmVhdGUgPSBtYWtlQ3JlYXRvcih7IGVuYWJsZUF1dG9GcmVlemU6IHRydWUgfSk7XG4gKiBjb25zdCBzdGF0ZSA9IGNyZWF0ZShcbiAqICAgYmFzZVN0YXRlLFxuICogICAoZHJhZnQpID0+IHtcbiAqICAgICBkcmFmdC5mb28uYmFyID0gJ3N0cjInO1xuICogICB9LFxuICogKTtcbiAqXG4gKiBleHBlY3Qoc3RhdGUpLnRvRXF1YWwoeyBmb286IHsgYmFyOiAnc3RyMicgfSwgYXJyOiBbXSB9KTtcbiAqIGV4cGVjdChzdGF0ZSkubm90LnRvQmUoYmFzZVN0YXRlKTtcbiAqIGV4cGVjdChzdGF0ZS5mb28pLm5vdC50b0JlKGJhc2VTdGF0ZS5mb28pO1xuICogZXhwZWN0KHN0YXRlLmFycikudG9CZShiYXNlU3RhdGUuYXJyKTtcbiAqIGV4cGVjdChPYmplY3QuaXNGcm96ZW4oc3RhdGUpKS50b0JlVHJ1dGh5KCk7XG4gKiBgYGBcbiAqL1xuY29uc3QgbWFrZUNyZWF0b3IgPSAoYXJnKSA9PiB7XG4gICAgaWYgKGFyZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3B0aW9uczogJHtTdHJpbmcoYXJnKX0sICdvcHRpb25zJyBzaG91bGQgYmUgYW4gb2JqZWN0LmApO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJnMSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiYXNlLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZShiYXNlLCAoZHJhZnQpID0+IGFyZzAuY2FsbCh0aGlzLCBkcmFmdCwgLi4uYXJncyksIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlID0gYXJnMDtcbiAgICAgICAgY29uc3QgbXV0YXRlID0gYXJnMTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICBpZiAodHlwZW9mIGFyZzEgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRpb25zKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvcHRpb25zOiAke29wdGlvbnN9LCAnb3B0aW9ucycgc2hvdWxkIGJlIGFuIG9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcmcpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBpc0RyYWZ0KGJhc2UpID8gY3VycmVudChiYXNlKSA6IGJhc2U7XG4gICAgICAgIGNvbnN0IG1hcmsgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMubWFyaylcbiAgICAgICAgICAgID8gKCh2YWx1ZSwgdHlwZXMpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hcmsgb2Ygb3B0aW9ucy5tYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFyayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1hcms6ICR7bWFya30sICdtYXJrJyBzaG91bGQgYmUgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXJrKHZhbHVlLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogb3B0aW9ucy5tYXJrO1xuICAgICAgICBjb25zdCBlbmFibGVQYXRjaGVzID0gKF9hID0gb3B0aW9ucy5lbmFibGVQYXRjaGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RyaWN0ID0gKF9iID0gb3B0aW9ucy5zdHJpY3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICBjb25zdCBlbmFibGVBdXRvRnJlZXplID0gKF9jID0gb3B0aW9ucy5lbmFibGVBdXRvRnJlZXplKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbmFibGVBdXRvRnJlZXplLFxuICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgIHN0cmljdCxcbiAgICAgICAgICAgIGVuYWJsZVBhdGNoZXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNEcmFmdGFibGUoc3RhdGUsIF9vcHRpb25zKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHN0YXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXNlIHN0YXRlOiBjcmVhdGUoKSBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdHMsIGFycmF5cywgU2V0LCBNYXAgb3IgdXNpbmcgbWFyaygpIHRvIG1hcmsgdGhlIHN0YXRlIGFzIGltbXV0YWJsZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZHJhZnQsIGZpbmFsaXplXSA9IGRyYWZ0aWZ5KHN0YXRlLCBfb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKCFpc0RyYWZ0YWJsZShzdGF0ZSwgX29wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhc2Ugc3RhdGU6IGNyZWF0ZSgpIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBTZXQsIE1hcCBvciB1c2luZyBtYXJrKCkgdG8gbWFyayB0aGUgc3RhdGUgYXMgaW1tdXRhYmxlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtkcmFmdCwgZmluYWxpemVdO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtdXRhdGUoZHJhZnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV2b2tlUHJveHkoZ2V0UHJveHlEcmFmdChkcmFmdCkpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KGRyYWZ0KTtcbiAgICAgICAgICAgIGlmICghaXNEcmFmdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNFcXVhbCh2YWx1ZSwgZHJhZnQpICYmXG4gICAgICAgICAgICAgICAgICAgIChwcm94eURyYWZ0ID09PSBudWxsIHx8IHByb3h5RHJhZnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3h5RHJhZnQub3BlcmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRWl0aGVyIHRoZSB2YWx1ZSBpcyByZXR1cm5lZCBhcyBhIG5ldyBub24tZHJhZnQgdmFsdWUsIG9yIG9ubHkgdGhlIGRyYWZ0IGlzIG1vZGlmaWVkIHdpdGhvdXQgcmV0dXJuaW5nIGFueSB2YWx1ZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3UmV0dXJuVmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVbUkFXX1JFVFVSTl9TWU1CT0xdO1xuICAgICAgICAgICAgICAgIGlmIChyYXdSZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfdmFsdWUgPSByYXdSZXR1cm5WYWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9vcHRpb25zLnN0cmljdCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdERyYWZ0OiBwcm94eURyYWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZVJhd1JldHVybjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZShbX3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZXR1cm5WYWx1ZSh7IHJvb3REcmFmdDogcHJveHlEcmFmdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplKFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZHJhZnQgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXR1cm5lZFByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChfb3B0aW9ucyA9PT0gcmV0dXJuZWRQcm94eURyYWZ0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWRQcm94eURyYWZ0Lm9wZXJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJldHVybiBhIG1vZGlmaWVkIGNoaWxkIGRyYWZ0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmluYWxpemUoW2N1cnJlbnQodmFsdWUpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluYWxpemUoW3ZhbHVlXSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4ocmV0dXJuVmFsdWUsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldm9rZVByb3h5KGdldFByb3h5RHJhZnQoZHJhZnQpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZShyZXN1bHQpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIGBjcmVhdGUoYmFzZVN0YXRlLCBjYWxsYmFjaywgb3B0aW9ucylgIHRvIGNyZWF0ZSB0aGUgbmV4dCBzdGF0ZVxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnLi4vaW5kZXgnO1xuICpcbiAqIGNvbnN0IGJhc2VTdGF0ZSA9IHsgZm9vOiB7IGJhcjogJ3N0cicgfSwgYXJyOiBbXSB9O1xuICogY29uc3Qgc3RhdGUgPSBjcmVhdGUoXG4gKiAgIGJhc2VTdGF0ZSxcbiAqICAgKGRyYWZ0KSA9PiB7XG4gKiAgICAgZHJhZnQuZm9vLmJhciA9ICdzdHIyJztcbiAqICAgfSxcbiAqICk7XG4gKlxuICogZXhwZWN0KHN0YXRlKS50b0VxdWFsKHsgZm9vOiB7IGJhcjogJ3N0cjInIH0sIGFycjogW10gfSk7XG4gKiBleHBlY3Qoc3RhdGUpLm5vdC50b0JlKGJhc2VTdGF0ZSk7XG4gKiBleHBlY3Qoc3RhdGUuZm9vKS5ub3QudG9CZShiYXNlU3RhdGUuZm9vKTtcbiAqIGV4cGVjdChzdGF0ZS5hcnIpLnRvQmUoYmFzZVN0YXRlLmFycik7XG4gKiBgYGBcbiAqL1xuY29uc3QgY3JlYXRlID0gbWFrZUNyZWF0b3IoKTtcblxuLyoqXG4gKiBgYXBwbHkoc3RhdGUsIHBhdGNoZXMpYCB0byBhcHBseSBwYXRjaGVzIHRvIHN0YXRlXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGUsIGFwcGx5IH0gZnJvbSAnLi4vaW5kZXgnO1xuICpcbiAqIGNvbnN0IGJhc2VTdGF0ZSA9IHsgZm9vOiB7IGJhcjogJ3N0cicgfSwgYXJyOiBbXSB9O1xuICogY29uc3QgW3N0YXRlLCBwYXRjaGVzXSA9IGNyZWF0ZShcbiAqICAgYmFzZVN0YXRlLFxuICogICAoZHJhZnQpID0+IHtcbiAqICAgICBkcmFmdC5mb28uYmFyID0gJ3N0cjInO1xuICogICB9LFxuICogICB7IGVuYWJsZVBhdGNoZXM6IHRydWUgfVxuICogKTtcbiAqIGV4cGVjdChzdGF0ZSkudG9FcXVhbCh7IGZvbzogeyBiYXI6ICdzdHIyJyB9LCBhcnI6IFtdIH0pO1xuICogZXhwZWN0KHBhdGNoZXMpLnRvRXF1YWwoW3sgb3A6ICdyZXBsYWNlJywgcGF0aDogWydmb28nLCAnYmFyJ10sIHZhbHVlOiAnc3RyMicgfV0pO1xuICogZXhwZWN0KHN0YXRlKS50b0VxdWFsKGFwcGx5KGJhc2VTdGF0ZSwgcGF0Y2hlcykpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KHN0YXRlLCBwYXRjaGVzLCBhcHBseU9wdGlvbnMpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIG9wLCBwYXRoIH0gPSBwYXRjaGVzW2ldO1xuICAgICAgICBpZiAoKCFwYXRoLmxlbmd0aCAmJiBvcCA9PT0gT3BlcmF0aW9uLlJlcGxhY2UpIHx8XG4gICAgICAgICAgICAocGF0aCA9PT0gJycgJiYgb3AgPT09IE9wZXJhdGlvbi5BZGQpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgICBwYXRjaGVzID0gcGF0Y2hlcy5zbGljZShpICsgMSk7XG4gICAgfVxuICAgIGNvbnN0IG11dGF0ZSA9IChkcmFmdCkgPT4ge1xuICAgICAgICBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGg6IF9wYXRoLCBvcCB9ID0gcGF0Y2g7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdW5lc2NhcGVQYXRoKF9wYXRoKTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gZHJhZnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0aC5sZW5ndGggLSAxOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IGdldFR5cGUoYmFzZSk7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHBhdGhbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Yga2V5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgocGFyZW50VHlwZSA9PT0gMCAvKiBEcmFmdFR5cGUuT2JqZWN0ICovIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFR5cGUgPT09IDEgLyogRHJhZnRUeXBlLkFycmF5ICovKSAmJlxuICAgICAgICAgICAgICAgICAgICAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicpKSB8fFxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGJhc2UgPT09ICdmdW5jdGlvbicgJiYga2V5ID09PSAncHJvdG90eXBlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXNlIGBpbmRleGAgaW4gU2V0IGRyYWZ0XG4gICAgICAgICAgICAgICAgYmFzZSA9IGdldChwYXJlbnRUeXBlID09PSAzIC8qIERyYWZ0VHlwZS5TZXQgKi8gPyBBcnJheS5mcm9tKGJhc2UpIDogYmFzZSwga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFwcGx5IHBhdGNoIGF0ICcke3BhdGguam9pbignLycpfScuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGUoYmFzZSk7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIG9yaWdpbmFsIHBhdGNoIGlzIG5vdCBtb2RpZmllZC5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVlcENsb25lKHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdGlvbi5SZXBsYWNlOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBEcmFmdFR5cGUuTWFwICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBEcmFmdFR5cGUuU2V0ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFwcGx5IHJlcGxhY2UgcGF0Y2ggdG8gc2V0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJhc2Vba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0aW9uLkFkZDpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogRHJhZnRUeXBlLkFycmF5ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBcIi1cIiBjaGFyYWN0ZXIgaXMgdXNlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4IHRoZSBlbmQgb2YgdGhlIGFycmF5IChzZWUgW1JGQzY5MDFdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjkwMikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFzIHRoZSBlZmZlY3Qgb2YgYXBwZW5kaW5nIHRoZSB2YWx1ZSB0byB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gJy0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYmFzZS5wdXNoKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIERyYWZ0VHlwZS5NYXAgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIERyYWZ0VHlwZS5TZXQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChiYXNlW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdGlvbi5SZW1vdmU6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIERyYWZ0VHlwZS5BcnJheSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBEcmFmdFR5cGUuTWFwICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIERyYWZ0VHlwZS5TZXQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBiYXNlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogJHtvcH0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKGlzRHJhZnQoc3RhdGUpKSB7XG4gICAgICAgIGlmIChhcHBseU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYXBwbHkgcGF0Y2hlcyB3aXRoIG9wdGlvbnMgdG8gYSBkcmFmdC5gKTtcbiAgICAgICAgfVxuICAgICAgICBtdXRhdGUoc3RhdGUpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGUoc3RhdGUsIG11dGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcHBseU9wdGlvbnMpLCB7IGVuYWJsZVBhdGNoZXM6IGZhbHNlIH0pKTtcbn1cblxuLyoqXG4gKiBgb3JpZ2luYWwoZHJhZnQpYCB0byBnZXQgb3JpZ2luYWwgc3RhdGUgaW4gdGhlIGRyYWZ0IG11dGF0aW9uIGZ1bmN0aW9uLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlLCBvcmlnaW5hbCB9IGZyb20gJy4uL2luZGV4JztcbiAqXG4gKiBjb25zdCBiYXNlU3RhdGUgPSB7IGZvbzogeyBiYXI6ICdzdHInIH0sIGFycjogW10gfTtcbiAqIGNvbnN0IHN0YXRlID0gY3JlYXRlKFxuICogICBiYXNlU3RhdGUsXG4gKiAgIChkcmFmdCkgPT4ge1xuICogICAgIGRyYWZ0LmZvby5iYXIgPSAnc3RyMic7XG4gKiAgICAgZXhwZWN0KG9yaWdpbmFsKGRyYWZ0LmZvbykpLnRvRXF1YWwoeyBiYXI6ICdzdHInIH0pO1xuICogICB9XG4gKiApO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIG9yaWdpbmFsKHRhcmdldCkge1xuICAgIGNvbnN0IHByb3h5RHJhZnQgPSBnZXRQcm94eURyYWZ0KHRhcmdldCk7XG4gICAgaWYgKCFwcm94eURyYWZ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3JpZ2luYWwoKSBpcyBvbmx5IHVzZWQgZm9yIGEgZHJhZnQsIHBhcmFtZXRlcjogJHt0YXJnZXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBwcm94eURyYWZ0Lm9yaWdpbmFsO1xufVxuXG4vKipcbiAqIFVzZSByYXdSZXR1cm4oKSB0byB3cmFwIHRoZSByZXR1cm4gdmFsdWUgdG8gc2tpcCB0aGUgZHJhZnQgY2hlY2sgYW5kIHRodXMgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZSwgcmF3UmV0dXJuIH0gZnJvbSAnLi4vaW5kZXgnO1xuICpcbiAqIGNvbnN0IGJhc2VTdGF0ZSA9IHsgZm9vOiB7IGJhcjogJ3N0cicgfSwgYXJyOiBbXSB9O1xuICogY29uc3Qgc3RhdGUgPSBjcmVhdGUoXG4gKiAgIGJhc2VTdGF0ZSxcbiAqICAgKGRyYWZ0KSA9PiB7XG4gKiAgICAgcmV0dXJuIHJhd1JldHVybihiYXNlU3RhdGUpO1xuICogICB9LFxuICogKTtcbiAqIGV4cGVjdChzdGF0ZSkudG9CZShiYXNlU3RhdGUpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHJhd1JldHVybih2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmF3UmV0dXJuKCkgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIHZhbHVlLicpO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXdSZXR1cm4oKSBtdXN0IGJlIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudC4nKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybigncmF3UmV0dXJuKCkgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3QoaW5jbHVkaW5nIHBsYWluIG9iamVjdCwgYXJyYXlzLCBTZXQsIE1hcCwgZXRjLikgb3IgYHVuZGVmaW5lZGAsIG90aGVyIHR5cGVzIGRvIG5vdCBuZWVkIHRvIGJlIHJldHVybmVkIHZpYSByYXdSZXR1cm4oKS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1JBV19SRVRVUk5fU1lNQk9MXTogW3ZhbHVlXSxcbiAgICB9O1xufVxuXG5jb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgc2ltcGxlIG9iamVjdChObyBwcm90b3R5cGUgY2hhaW4gb2JqZWN0IG9yIGlmcmFtZSBzYW1lLW9yaWdpbiBvYmplY3QpLFxuICogc3VwcG9ydCBjYXNlOiBodHRwczovL2dpdGh1Yi5jb20vdW5hZGxpYi9tdXRhdGl2ZS9pc3N1ZXMvMTdcbiAqL1xuY29uc3QgaXNTaW1wbGVPYmplY3QgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgIGlmIChwcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG90eXBlLCAnY29uc3RydWN0b3InKSAmJlxuICAgICAgICBwcm90b3R5cGUuY29uc3RydWN0b3I7XG4gICAgaWYgKGNvbnN0cnVjdG9yID09PSBPYmplY3QpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAodHlwZW9mIGNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0b3IpID09PSBjb25zdHJ1Y3RvclN0cmluZyk7XG59O1xuY29uc3QgbWFya1NpbXBsZU9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChpc1NpbXBsZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFUeXBlcy5pbW11dGFibGU7XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5cbi8qKlxuICogQ2FzdCBhIHZhbHVlIHRvIGFuIERyYWZ0IHR5cGUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNhc3REcmFmdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQ2FzdCBhIHZhbHVlIHRvIGFuIEltbXV0YWJsZSB0eXBlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYXN0SW1tdXRhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBDYXN0IGEgdmFsdWUgdG8gYW4gTXV0YWJsZSB0eXBlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYXN0TXV0YWJsZShkcmFmdCkge1xuICAgIHJldHVybiBkcmFmdDtcbn1cblxuZXhwb3J0IHsgYXBwbHksIGNhc3REcmFmdCwgY2FzdEltbXV0YWJsZSwgY2FzdE11dGFibGUsIGNyZWF0ZSwgY3VycmVudCwgaXNEcmFmdCwgaXNEcmFmdGFibGUsIG1ha2VDcmVhdG9yLCBtYXJrU2ltcGxlT2JqZWN0LCBvcmlnaW5hbCwgcmF3UmV0dXJuLCB1bnNhZmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11dGF0aXZlLmVzbS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mutative/dist/mutative.esm.mjs\n");

/***/ })

};
;